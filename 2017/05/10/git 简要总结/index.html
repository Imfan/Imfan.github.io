<!DOCTYPE html><html><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description"><title> | Imfan</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=0.0.0"><link rel="stylesheet" type="text/css" href="/css/normalize.min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/1.0.0/pure-min.css"><link rel="stylesheet" type="text/css" href="/css/grids-responsive-min.css"><link rel="stylesheet" href="/css/font-awesome.min.css"><script type="text/javascript" src="/js/jquery.3.3.1.min.js"></script><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">Imfan</h1><a id="logo" href="/.">Imfan</a><p class="description"></p></div><div id="nav-menu"><a class="current" href="/."><i class="fa fa-home"> Start</i></a><a href="/archives/"><i class="fa fa-archive"> Archiv</i></a><a href="/about/"><i class="fa fa-user"> Über</i></a><a href="/atom.xml"><i class="fa fa-rss"> RSS</i></a></div></div><div class="pure-g" id="layout"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title"></h1><div class="post-meta">May 10, 2017</div><div class="post-content"><h1 id="git-简要总结"><a href="#git-简要总结" class="headerlink" title="git 简要总结"></a>git 简要总结</h1><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><ul>
<li>工作区（working Directory）就是你在电脑里能看到的目录</li>
<li>版本库（repository) 工作区有一个隐藏目录.git，这个不算工作区，是版本库</li>
<li>暂存区 Git的版本库里存了很多东西，其中最重要的就是称为stage（或者叫index）的暂存区</li>
<li>master 还有Git为我们自动创建的第一个分支master</li>
<li><p>HEAD 指向master的一个指针叫HEAD</p>
<blockquote>
<p>我们把文件往Git版本库里添加的时候，是分两步执行的：</p>
</blockquote>
<blockquote>
<p>第一步是用<code>git add</code>把文件添加进去，实际上就是把文件修改添加到暂存区；</p>
</blockquote>
<blockquote>
<p>第二步是用<code>git commit</code>提交更改，实际上就是把暂存区的所有内容提交到当前分支。</p>
</blockquote>
<blockquote>
<p>因为我们创建Git版本库时，Git自动为我们创建了唯一一个master分支，所以，现在，<code>git commit</code>就是往master分支上提交更改。</p>
</blockquote>
<blockquote>
<p>可以简单理解为，需要提交的文件修改通通放到暂存区，然后，一次性提交暂存区的所有修改</p>
</blockquote>
</li>
</ul>
<h2 id="安装git"><a href="#安装git" class="headerlink" title="安装git"></a>安装git</h2><blockquote>
<p>mac上</p>
</blockquote>
<ol>
<li>安装brew<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">`  /usr/bin/ruby -e &quot;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)&quot;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>`  2. 安装git<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">`➜   brew install git</span><br><span class="line"># 若出现下面的情况表示安装成功</span><br><span class="line">➜   git --version</span><br><span class="line">git version 2.10.1</span><br></pre></td></tr></table></figure></p>
<p>`</p>
<blockquote>
<p>ubuntu上</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">`root@fan:# sudo apt-get install git</span><br><span class="line">sudo: 无法解析主机：fan</span><br><span class="line">正在读取软件包列表... 完成</span><br><span class="line">正在分析软件包的依赖关系树</span><br><span class="line">正在读取状态信息... 完成</span><br><span class="line">git 已经是最新版 (1:2.7.4-0ubuntu1)。</span><br><span class="line">升级了 0 个软件包，新安装了 0 个软件包，要卸载 0 个软件包，有 0 个软件包未被升级。</span><br></pre></td></tr></table></figure>
<p>`#### 安装成功后还需要配置git<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">`$ git config --global user.name &quot;Your Name&quot;</span><br><span class="line">$ git config --global user.email &quot;email@example.com&quot;</span><br><span class="line"># 配置别名</span><br><span class="line">git config --global alias.st status #查看状态</span><br><span class="line">git config --global alias.co checkout </span><br><span class="line">git config --global alias.ci commit #提交</span><br><span class="line">git config --global alias.br branch #分支</span><br><span class="line">git config --global alias.unstage &apos;reset HEAD --&apos; </span><br><span class="line">git config --global alias.last &apos;log -1 HEAD&apos;</span><br><span class="line">git config --global alias.clog &quot;log --color --graph --pretty=format:&apos;%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)\&lt;%an\&gt;%Creset&apos; --abbrev-commit&quot;</span><br><span class="line">git config --global alias.llog &quot;log -graph --pretty=oneline --abbrev-commit&quot;</span><br></pre></td></tr></table></figure></p>
<p>`<strong>还可以设置编辑器</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">`git config --global core.editor vim</span><br></pre></td></tr></table></figure></p>
<p>`## 创建本地版本库</p>
<ul>
<li>创建裸仓库 <code>git --base init</code><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">`sh-3.2# pwd</span><br><span class="line">/Applications/XAMPP/htdocs</span><br><span class="line">sh-3.2# mkdir learngit</span><br><span class="line">sh-3.2# cd learngit/</span><br><span class="line">sh-3.2# #初始化目录为git可以管理的仓库</span><br><span class="line">sh-3.2# git init</span><br><span class="line">Initialized empty Git repository in /Applications/XAMPP/xamppfiles/htdocs/learngit/.git/</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>`查看当前目录下会多了一个.git目录<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">`sh-3.2# ls -ah</span><br><span class="line">.	..	.git</span><br></pre></td></tr></table></figure></p>
<p>`\&lt;span style = ‘color:red’><strong>在这时最好先建好.gitignore 文件然后在commit，或者克隆远程仓库前，确保远程仓库.gitignore文件正确</strong>\&lt;/span></p>
<h2 id="远程仓库的管理和使用"><a href="#远程仓库的管理和使用" class="headerlink" title="远程仓库的管理和使用"></a>远程仓库的管理和使用</h2><h4 id="克隆远程仓库"><a href="#克隆远程仓库" class="headerlink" title="克隆远程仓库"></a>克隆远程仓库</h4><p>一次 Git 克隆会建立你自己的本地分支 master 和远程分支 origin/master，它们都指向 origin/master 分支的最后一次提交<br>克隆操作会默认使用的 master作为分支名 和 origin远程库名</p>
<p><code>git clone [url]</code> 或者 <code>git clone [url] + 要克隆到哪个目录</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">`$ git clone git://github.com/schacon/grit.git</span><br><span class="line">$ git clone git://github.com/schacon/grit.git mygrit</span><br></pre></td></tr></table></figure></p>
<p>`#### 添加远程仓库</p>
<ul>
<li><strong><code>git remote add [shortname] [url]</code></strong> 添加新的远程仓库    </li>
<li><p><strong><code>git remote</code></strong> 查看当前配置中每个远程库的简短名称</p>
<ol>
<li><code>git remote -v</code>显示克隆地址</li>
</ol>
</li>
<li><p><strong><code>git pull</code></strong> 命令自动抓取数据下来，然后将远端分支自动合并到本地仓库中当前分支</p>
</li>
<li><p><strong><code>git fetch [shortname]</code></strong> 要抓取所有远程仓库有的，但本地仓库的远程分支没有的信息。如果是克隆了一个仓库，此命令会抓取从你上次克隆以来别人上传到此远程仓库中的所有更新。<br><strong>fetch 命令只是将远端的数据拉到本地仓库的远程分支，并不自动合并到当前工作分支，只有当你确实准备好了，才能手工合并</strong></p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">`$ git fetch origin</span><br><span class="line">remote: Counting objects: 20, done.</span><br><span class="line">remote: Compressing objects: 100% (14/14), done.</span><br><span class="line">remote: Total 15 (delta 5), reused 0 (delta 0)</span><br><span class="line">Unpacking objects: 100% (15/15), done.</span><br><span class="line">From git@github.com:schacon/simplegit</span><br><span class="line"> - [new branch]()      serverfix    -\&gt; origin/serverfix</span><br></pre></td></tr></table></figure>
<p><code>在 fetch 操作下载好新的远程分支之后，你仍然无法在本地编辑该远程仓库中的分支。换句话说，在本例中，你不会有一个新的serverfix 分支，有的只是一个你无法移动的 origin/serverfix 指针
如果要把该内容合并到当前分支，可以运行</code>git merge origin/serverfix`。如果想要一份自己的 serverfix 来开发，可以在远程分支的基础上分化出一个新的分支来：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">`$ git checkout -b serverfix origin/serverfix</span><br><span class="line">Branch serverfix set up to track remote branch refs/remotes/origin/serverfix.</span><br><span class="line">Switched to a new branch &quot;serverfix&quot;</span><br></pre></td></tr></table></figure></p>
<p>`这会切换到新建的 serverfix 本地分支，其内容同远程分支 origin/serverfix 一致，这样你就可以在里面继续开发了。</p>
<blockquote>
<p>举例</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">`root@fan:/home/wwwroot/git# git init</span><br><span class="line">初始化空的 Git 仓库于 /home/wwwroot/git/.git/</span><br><span class="line">root@fan:/home/wwwroot/git# git status</span><br><span class="line">位于分支 master</span><br><span class="line"></span><br><span class="line">初始提交</span><br><span class="line"></span><br><span class="line">无文件要提交（创建/拷贝文件并使用 &quot;git add&quot; 建立跟踪）</span><br><span class="line">root@fan:/home/wwwroot/git# git remote add demo git@git.coding.net:fan_code/ceshi2.git</span><br><span class="line">root@fan:/home/wwwroot/git# git remote</span><br><span class="line">demo</span><br><span class="line">root@fan:/home/wwwroot/git# git remote -v</span><br><span class="line">demo	git@git.coding.net:fan_code/ceshi2.git (fetch)</span><br><span class="line">demo	git@git.coding.net:fan_code/ceshi2.git (push)</span><br><span class="line">root@fan:/home/wwwroot/git# git fetch demo </span><br><span class="line">remote: Counting objects: 7993, done.</span><br><span class="line">remote: Compressing objects: 100% (4985/4985), done.</span><br><span class="line">remote: Total 7993 (delta 2470), reused 7993 (delta 2470)</span><br><span class="line">接收对象中: 100% (7993/7993), 7.59 MiB | 337.00 KiB/s, 完成.</span><br><span class="line">处理 delta 中: 100% (2470/2470), 完成.</span><br><span class="line">来自 git.coding.net:fan_code/ceshi2</span><br><span class="line"> - [新分支]()          master     -\&gt; demo/master</span><br></pre></td></tr></table></figure>
<p><code>现在，远程仓库</code>[shortname]`的主干分支（master）已经完全可以在本地访问了，对应的名字是 demo/master，你可以将它合并到自己的某个分支，或者切换到这个分支，看看有些什么有趣的更新。</p>
<h4 id="修改远程仓库地址"><a href="#修改远程仓库地址" class="headerlink" title="修改远程仓库地址"></a>修改远程仓库地址</h4><p>Git 仓库地址修改办法 <code>git remote set-url origin [NEW_URL]</code></p>
<h4 id="推送数据到远程仓库"><a href="#推送数据到远程仓库" class="headerlink" title="推送数据到远程仓库"></a>推送数据到远程仓库</h4><ul>
<li><code>git push [remote-name] [branch-name]</code></li>
</ul>
<blockquote>
<p>例如：把本地的 master 分支推送到origin 服务器上<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">`$ git push origin master</span><br></pre></td></tr></table></figure></p>
</blockquote>
<p>`&gt; 把本地的 master 分支推送到 origin 上并改名为 test<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">`$ git push origin master:test</span><br></pre></td></tr></table></figure></p>
<p>`</p>
<h4 id="查看远程仓库信息"><a href="#查看远程仓库信息" class="headerlink" title="查看远程仓库信息"></a>查看远程仓库信息</h4><ul>
<li><code>git remote show [remote-name]</code> 查看某个远程仓库的详细信息<blockquote>
<p>举例</p>
</blockquote>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">`$ git remote show origin</span><br><span class="line">* remote origin</span><br><span class="line">  URL: git@github.com:defunkt/github.git</span><br><span class="line">  Remote branch merged with &apos;git pull&apos; while on branch issues</span><br><span class="line">issues</span><br><span class="line">  Remote branch merged with &apos;git pull&apos; while on branch master</span><br><span class="line">master</span><br><span class="line">  New remote branches (next fetch will store in remotes/origin)</span><br><span class="line">caching</span><br><span class="line">  Stale tracking branches (use &apos;git remote prune&apos;)</span><br><span class="line">libwalker</span><br><span class="line">walker2</span><br><span class="line">  Tracked remote branches</span><br><span class="line">acl</span><br><span class="line">apiv2</span><br><span class="line">dashboard2</span><br><span class="line">issues</span><br><span class="line">master</span><br><span class="line">postgres</span><br><span class="line">  Local branch pushed with &apos;git push&apos;</span><br><span class="line">master:master</span><br></pre></td></tr></table></figure>
<p><code>它告诉我们，运行</code>git push` 时缺省推送的分支是什么（译注：最后两行）。它还显示了有哪些远端分支还没有同步到本地（译注：第六行的caching 分支），哪些已同步到本地的远端分支在远端服务器上已被删除（译注：Stale tracking branches 下面的两个分支），以及运行git pull 时将自动合并哪些分支（译注：前四行中列出的 issues 和 master 分支）。</p>
<h4 id="远程仓库的移除和重命名"><a href="#远程仓库的移除和重命名" class="headerlink" title="远程仓库的移除和重命名"></a>远程仓库的移除和重命名</h4><ul>
<li><code>git remote rename 原名 新名</code></li>
<li><code>git remote rm 远程仓库别名</code> 碰到远端仓库服务器迁移，或者原来的克隆镜像不再使用，又或者某个参与者不再贡献代码，那么需要移除对应的远端仓库，可以运行</li>
</ul>
<h2 id="文件管理"><a href="#文件管理" class="headerlink" title="文件管理"></a>文件管理</h2><h4 id="将已被git跟踪的文件移除跟踪"><a href="#将已被git跟踪的文件移除跟踪" class="headerlink" title="将已被git跟踪的文件移除跟踪"></a>将已被git跟踪的文件移除跟踪</h4><p>另外一种情况是，我们想把文件从Git仓库中删除（亦即从暂存区域移除），但仍然希望保留在当前工作目录中。换句话说，仅是从跟踪清单中删除。比如一些大型日志文件或者一堆.a 编译文件，不小心纳入仓库后，要移除跟踪但不删除文件，以便稍后在 .gitignore 文件中补上，用 –cached 选项即可：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">`$ git rm --cached readme.txt</span><br></pre></td></tr></table></figure></p>
<p>`</p>
<h4 id="删除文件"><a href="#删除文件" class="headerlink" title="删除文件"></a>删除文件</h4><p>后面可以列出文件或者目录的名字，也可以使用 glob 模式。比方说：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">`$ git rm log/\*.log</span><br></pre></td></tr></table></figure></p>
<p>`注意到星号*之前的反斜杠\，因为Git有它自己的文件模式扩展匹配方式，所以我们不用shell来帮忙展开（译注：实际上不加反斜杠也可以运行，只不过按照shell扩展的话，仅仅删除指定目录下的文件而不会递归匹配。上面的例子本来就指定了目录，所以效果等同，但下面的例子就会用递归方式匹配，所以必须加反斜 杠。）。此命令删除所有log/ 目录下扩展名为 .log 的文件。类似的比如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">`$ git rm \*</span><br></pre></td></tr></table></figure></p>
<p>`会递归删除当前目录及其子目录中所有  结尾的文件。</p>
<h4 id="移动文件"><a href="#移动文件" class="headerlink" title="移动文件"></a>移动文件</h4><p>不像其他的VCS系统，Git并不跟踪文件移动操作。如果在Git中重命名了某个文件，仓库中存储的元数据并不会体现出这是一次改名操作。不过Git非常聪明，它会推断出究竟发生了什么，至于具体是如何做到的，我们稍后再谈。</p>
<p>既然如此，当你看到 Git 的 mv 命令时一定会困惑不已。要在 Git 中对文件改名，可以这么做：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">`$ git mv file_from file_to</span><br></pre></td></tr></table></figure></p>
<p>`它会恰如预期般正常工作。实际上，即便此时查看状态信息，也会明白无误地看到关于重命名操作的说明：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">`$ git mv README.txt README</span><br><span class="line">$ git status</span><br><span class="line"># On branch master</span><br><span class="line"># Your branch is ahead of &apos;origin/master&apos; by 1 commit.</span><br><span class="line"># </span><br><span class="line"># Changes to be committed:</span><br><span class="line">#   (use &quot;git reset HEAD </span><br><span class="line"></span><br><span class="line">...&quot; to unstage)</span><br><span class="line"># </span><br><span class="line">#       renamed:    README.txt -\&gt; README</span><br><span class="line">#</span><br></pre></td></tr></table></figure></p>
<p>`其实，运行 git mv 就相当于运行了下面三条命令：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">`$ mv README.txt README</span><br><span class="line">$ git rm README.txt</span><br><span class="line">$ git add README</span><br></pre></td></tr></table></figure></p>
<p><code>如此分开操作，Git也会意识到这是一次改名，所以不管何种方式都一样。当然，直接用</code>git mv` 轻便得多，不过有时候用其他工具批处理改名的话，要记得在提交前删除老的文件名，再添加新的文件名。</p>
<h4 id="文件对比"><a href="#文件对比" class="headerlink" title="文件对比"></a>文件对比</h4><ul>
<li><strong>git diff</strong><br>  比较工作区和暂存区文件差异</li>
<li><strong>git diff –staged/–cached</strong><br>  比较暂存区和版本库文件差异</li>
<li><strong>git diff HEAD</strong> 可以查看工作区和版本库里面最新版本的区别 </li>
<li><p><strong>git diff HEAD – 文件名</strong>    可以查看指定文件工作区和版本库里面最新版本的区别</p>
<blockquote>
<p>举例</p>
</blockquote>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">`root@fan:/home/wwwroot/Demo# vim t2</span><br><span class="line">root@fan:/home/wwwroot/Demo# git diff</span><br><span class="line">diff --git a/t2 b/t2</span><br><span class="line">index 9bc7ad0..2672a75 100644</span><br><span class="line">--- a/t2</span><br><span class="line">+++ b/t2</span><br><span class="line">@@ -1 +1,2 @@</span><br><span class="line"> t2</span><br><span class="line">+t2</span><br><span class="line">root@fan:/home/wwwroot/Demo# git add t2</span><br><span class="line">root@fan:/home/wwwroot/Demo# git diff </span><br><span class="line">root@fan:/home/wwwroot/Demo# git diff --staged </span><br><span class="line">diff --git a/t2 b/t2</span><br><span class="line">index 9bc7ad0..2672a75 100644</span><br><span class="line">--- a/t2</span><br><span class="line">+++ b/t2</span><br><span class="line">@@ -1 +1,2 @@</span><br><span class="line"> t2</span><br><span class="line">+t2</span><br><span class="line">root@fan:/home/wwwroot/Demo# git commit -m &apos;+t2&apos;</span><br><span class="line">[master 8a74487]() +t2</span><br><span class="line"> 1 file changed, 1 insertion(+)</span><br><span class="line">root@fan:/home/wwwroot/Demo# git status</span><br><span class="line">位于分支 master</span><br><span class="line">您的分支领先 &apos;origin/master&apos; 共 5 个提交。</span><br><span class="line">  （使用 &quot;git push&quot; 来发布您的本地提交）</span><br><span class="line">无文件要提交，干净的工作区</span><br><span class="line">root@fan:/home/wwwroot/Demo# git diff</span><br><span class="line">root@fan:/home/wwwroot/Demo# git diff --staged</span><br></pre></td></tr></table></figure>
<p>  `</p>
<h2 id="提交历史"><a href="#提交历史" class="headerlink" title="提交历史"></a>提交历史</h2><h4 id="查看"><a href="#查看" class="headerlink" title="查看"></a>查看</h4><p><code>git log</code> 有许多选项可以帮助你搜寻感兴趣的提交，接下来我们介绍些最常用的。</p>
</li>
</ul>
<p>我们常用 <code>-p</code> 选项展开显示每次提交的内容差异， </p>
<ul>
<li><strong><code>-2</code> 则仅显示最近的两次更新：</strong><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">`$ git log -p -2</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>`* <strong>–stat，仅显示简要的增改行数统计</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">`$ git log --stat</span><br></pre></td></tr></table></figure></p>
<p><code>* **</code>–pretty`&nbsp;选项**</p>
<pre><code>可以指定使用完全不同于默认格式的方式展示提交历史。比如用oneline将每个提交放在一行显示，这在提交数很大时非常有用** 
</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">`$ git log --pretty=oneline</span><br><span class="line">edde8f5624c75017e81004b221d2a70e5ed31092 update README.md</span><br><span class="line">75cc8c7ad7cf14f6eaded270c6b472b0b18accbd Initial commit</span><br></pre></td></tr></table></figure>
<p><code>* **还可以用</code>oneline<code>结合</code>–graph`选项**</p>
<pre><code>显示ASCII图形表示的分支合并历史，形象地展示了每个提交所在的分支及其分化衍合情况, `--abbrev-commit` 仅显示sha-1前几个字符，而非所有字符** 
</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">`$ git log --graph --pretty=oneline --abbrev-commit</span><br><span class="line">*   6be44b4 merge dev</span><br><span class="line">|\  </span><br><span class="line">| * d081be9 I am dev</span><br><span class="line">* | c65bc40 I am master</span><br><span class="line">|/  </span><br><span class="line">* aaa7a54 初始化</span><br></pre></td></tr></table></figure>
<p>`* <strong>format</strong></p>
<pre><code>可以定制要显示的记录格式，这样的输出便于后期编程提取分析
</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">`$ git log --pretty=format:&quot;%h - %an, %ar : %s&quot;</span><br><span class="line">ca82a6d - Scott Chacon, 11 months ago : changed the version number</span><br><span class="line">085bb3b - Scott Chacon, 11 months ago : removed unnecessary test code</span><br><span class="line">a11bef0 - Scott Chacon, 11 months ago : first commit</span><br></pre></td></tr></table></figure>
<p>`&gt; <strong>格式占位符说明</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">`选项	 说明</span><br><span class="line">%H	提交对象（commit）的完整哈希字串</span><br><span class="line">%h	提交对象的简短哈希字串</span><br><span class="line">%T	树对象（tree）的完整哈希字串</span><br><span class="line">%t	树对象的简短哈希字串</span><br><span class="line">%P	父对象（parent）的完整哈希字串</span><br><span class="line">%p	父对象的简短哈希字串</span><br><span class="line">%an	作者（author）的名字</span><br><span class="line">%ae	作者的电子邮件地址</span><br><span class="line">%ad	作者修订日期（可以用 -date= 选项定制格式）</span><br><span class="line">%ar	作者修订日期，按多久以前的方式显示</span><br><span class="line">%cn	提交者(committer)的名字</span><br><span class="line">%ce	提交者的电子邮件地址</span><br><span class="line">%cd	提交日期</span><br><span class="line">%cr	提交日期，按多久以前的方式显示</span><br><span class="line">%s	提交说明</span><br></pre></td></tr></table></figure></p>
<p><code>*</code>git log` 支持的其他命令选项<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">`选项 说明</span><br><span class="line">-p 按补丁格式显示每个更新之间的差异。</span><br><span class="line">--stat 显示每次更新的文件修改统计信息。</span><br><span class="line">--shortstat 只显示 --stat 中最后的行数修改添加移除统计。</span><br><span class="line">--name-only 仅在提交信息后显示已修改的文件清单。</span><br><span class="line">--name-status 显示新增、修改、删除的文件清单。</span><br><span class="line">--abbrev-commit 仅显示 SHA-1 的前几个字符，而非所有的 40 个字符。</span><br><span class="line">--relative-date 使用较短的相对时间显示（比如，“2 weeks ago”）。</span><br><span class="line">--graph 显示 ASCII 图形表示的分支合并历史。</span><br><span class="line">--pretty 使用其他格式显示历史提交信息。可用的选项包括 oneline，short，full，fuller 和 format（后跟指定格式）。</span><br></pre></td></tr></table></figure></p>
<p>`* <strong>过滤log输出</strong></p>
<blockquote>
<p>选项 说明</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">`-(n)	仅显示最近的 n 条提交</span><br><span class="line">--since, --after 仅显示指定时间之后的提交。</span><br><span class="line">--until, --before 仅显示指定时间之前的提交。</span><br><span class="line">--author 仅显示指定作者相关的提交。</span><br><span class="line">--committer 仅显示指定提交者相关的提交。</span><br></pre></td></tr></table></figure>
<p>`&gt; 例如</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">`$ git log --pretty=&quot;%h - %s&quot; --author=gitster --since=&quot;2008-10-01&quot;  --before=&quot;2008-11-01&quot; --no-merges -- t/</span><br></pre></td></tr></table></figure>
<p>`</p>
<h4 id="修改最后一次提交"><a href="#修改最后一次提交" class="headerlink" title="修改最后一次提交"></a>修改最后一次提交</h4><p>有时候我们提交完了才发现漏掉了几个文件没有加，或者提交信息写错了。想要撤消刚才的提交操作，可以使用<code>--amend</code>选项重新提交：启动文本编辑器后，会看到上次提交时的说明，编辑它确认没问题后保存退出，就会使用新的提交说明覆盖刚才失误的提交。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">`$ git commit -m &apos;initial commit&apos;</span><br><span class="line">$ git add forgotten_file</span><br><span class="line">$ git commit --amend</span><br></pre></td></tr></table></figure>
<p>`上面的三条命令最终只是产生一个提交，第二个提交命令修正了第一个的提交内容。</p>
<blockquote>
<p>例如：本机mac举例</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">`root@fan:/home/wwwroot/Demo# vim README.md </span><br><span class="line">root@fan:/home/wwwroot/Demo# vim test.md </span><br><span class="line">root@fan:/home/wwwroot/Demo# git log --pretty=oneline --abbrev-commit -2</span><br><span class="line">097860c one</span><br><span class="line">90a8fec phpstorm idea</span><br><span class="line">root@fan:/home/wwwroot/Demo# git add README.md </span><br><span class="line">root@fan:/home/wwwroot/Demo# git commit -m &apos;two&apos;</span><br><span class="line">[master 490cf35]() two</span><br><span class="line"> 1 file changed, 1 insertion(+)</span><br><span class="line">root@fan:/home/wwwroot/Demo# git status</span><br><span class="line">位于分支 master</span><br><span class="line">您的分支领先 &apos;origin/master&apos; 共 2 个提交。</span><br><span class="line">  （使用 &quot;git push&quot; 来发布您的本地提交）</span><br><span class="line">尚未暂存以备提交的变更：</span><br><span class="line">  （使用 &quot;git add \&lt;文件\&gt;...&quot; 更新要提交的内容）</span><br><span class="line">  （使用 &quot;git checkout -- \&lt;文件\&gt;...&quot; 丢弃工作区的改动）</span><br><span class="line">修改：     test.md</span><br><span class="line">修改尚未加入提交（使用 &quot;git add&quot; 和/或 &quot;git commit -a&quot;）</span><br><span class="line">root@fan:/home/wwwroot/Demo# git add test.md </span><br><span class="line">root@fan:/home/wwwroot/Demo# git log --pretty=oneline --abbrev-commit -2</span><br><span class="line">490cf35 two</span><br><span class="line">097860c one</span><br><span class="line">root@fan:/home/wwwroot/Demo# git commit --amend </span><br><span class="line">[master 372f01e]() ootwo</span><br><span class="line"> Date: Tue Dec 6 20:13:35 2016 +0800</span><br><span class="line"> 2 files changed, 2 insertions(+)</span><br><span class="line">root@fan:/home/wwwroot/Demo# git log --pretty=oneline --abbrev-commit -2</span><br><span class="line">372f01e ootwo</span><br><span class="line">097860c one</span><br></pre></td></tr></table></figure>
<p>`</p>
<h2 id="git-各种撤销操作"><a href="#git-各种撤销操作" class="headerlink" title="git 各种撤销操作"></a>git 各种撤销操作</h2><h3 id="版本回退"><a href="#版本回退" class="headerlink" title="版本回退"></a>版本回退</h3><blockquote>
<h4 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h4><p>类似3628164…882e1e0的是<code>commit_id</code>（版本号），和SVN不一样，Git的<code>commit_id</code>不是1，2，3……递增的数字，而是一个SHA1计算出来的一个非常大的数字，用十六进制表示，而且你看到的<code>commit_id</code>和我的肯定不一样，以你自己的为准。为什么<code>commit_id</code>需要用这么一大串数字表示呢？因为Git是分布式的版本控制系统，后面我们还要研究多人在同一个版本库里工作，如果大家都用1，2，3……作为版本号，那肯定就冲突了。<br>  每提交一个新版本，实际上Git就会把它们自动串成一条时间线。如果使用可视化工具查看Git历史，就可以更清楚地看到提交历史的时间线</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">`root@fan:/home/wwwroot/Demo# git log --pretty=oneline</span><br><span class="line">8a744873ac755647767abd149adef2e86ae53d71 +t2</span><br><span class="line">97a15f36b57f6a0c588a058f654901ebeab6de31 +t1</span><br><span class="line">ec30b4cb269ca10560b9abfe203fdd7a5abc7cfb 初始化</span><br></pre></td></tr></table></figure>
<p><code>* **</code>HEAD<code>指向的版本就是当前版本，</code>HEAD^<code>指的是上一个版本，</code>HEAD^^<code>指的是上上个版本。因此，Git允许我们在版本的历史之间穿梭，使用命令</code>git reset –hard commit_id`。commit id版本号没必要写全，前几位就可以了，Git会自动去找** </p>
<ul>
<li><p><strong>穿梭前，用<code>git log</code>可以查看提交历史，以便确定要回退到哪个版本。要重返未来，用<code>git reflog</code>查看命令提交历史，以便确定要回到未来的哪个版本</strong></p>
<blockquote>
<p>举例</p>
</blockquote>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">`root@fan:/home/wwwroot/Demo# git log --pretty=oneline --abbrev-commit </span><br><span class="line">8a74487 +t2</span><br><span class="line">97a15f3 +t1</span><br><span class="line">ec30b4c 初始化</span><br><span class="line">root@fan:/home/wwwroot/Demo# git reset --hard HEAD^</span><br><span class="line">HEAD 现在位于 97a15f3 +t1</span><br><span class="line">root@fan:/home/wwwroot/Demo# git log --pretty=oneline --abbrev-commit </span><br><span class="line">97a15f3 +t1</span><br><span class="line">ec30b4c 初始化</span><br><span class="line">root@fan:/home/wwwroot/Demo# git reflog</span><br><span class="line">97a15f3 HEAD@&#123;0&#125;: reset: moving to HEAD^</span><br><span class="line">8a74487 HEAD@&#123;1&#125;: commit: +t2</span><br><span class="line">97a15f3 HEAD@&#123;2&#125;: commit: +t1</span><br><span class="line">ec30b4c HEAD@&#123;3&#125;: commit: 初始化</span><br><span class="line">root@fan:/home/wwwroot/Demo# git reset --hard 8a74487</span><br><span class="line">HEAD 现在位于 8a74487 +t2</span><br><span class="line">root@fan:/home/wwwroot/Demo# git log --pretty=oneline --abbrev-commit </span><br><span class="line">8a74487 +t2</span><br><span class="line">97a15f3 +t1</span><br><span class="line">ec30b4c 初始化</span><br><span class="line">root@fan:/home/wwwroot/Demo# git reflog</span><br><span class="line">8a74487 HEAD@&#123;0&#125;: reset: moving to 8a74487</span><br><span class="line">97a15f3 HEAD@&#123;1&#125;: reset: moving to HEAD^</span><br><span class="line">8a74487 HEAD@&#123;2&#125;: commit: +t2</span><br><span class="line">97a15f3 HEAD@&#123;3&#125;: commit: +t1</span><br><span class="line">ec30b4c HEAD@&#123;4&#125;: commit: 初始化</span><br></pre></td></tr></table></figure>
<p>  `###  撤销文件修改</p>
</li>
</ul>
<blockquote>
<p>假如现在工作区，暂存区某个文件为版本2，版本库为版本1，修改工作区文件后，工作区变为版本3，运行命令git reset HAED file ，暂存区变为版本1，跟版本库一致，而工作区的版本还为版本3</p>
</blockquote>
<ul>
<li><p><strong>场景1：使用git checkout — readme.txt丢弃工作区修改</strong></p>
<p>  当你改乱了工作区某个文件的内容，想直接丢弃工作区的修改时，用命令<code>git checkout -- file</code>。命令<code>git checkout — readme.txt</code></p>
<p>  把readme.txt文件在工作区的修改全部撤销，这里有两种情况：一种是readme.txt自修改后还没有被放到暂存区，现在，撤销修改就回到和版本库一模一样的状态；</p>
<p>  一种是readme.txt已经添加到暂存区后，又作了修改，现在，撤销修改就回到添加到暂存区后的状态。</p>
<p>  总之，就是让这个文件回到最近一次<code>git commit</code>或<code>git add</code>时的状态。 </p>
</li>
<li><p><strong>场景2：使用git reset HEAD file丢弃暂存区修改</strong></p>
<p>  当你不但改乱了工作区某个文件的内容，还添加到了暂存区时，添加完之后又修改了工作区，想丢弃暂存区的修改，分两步，</p>
<ol>
<li><p>第一步用命令<code>git reset HEAD file</code>，</p>
<p>用命令<code>git reset HEAD file</code>可以把暂存区的修改撤销掉（unstage），而工作区的文件没有变化</p>
<p>就回到了场景1，</p>
</li>
<li>第二步按场景1操作。</li>
</ol>
</li>
<li><p><strong>场景3：版本回退</strong></p>
<p>  已经提交了不合适的修改到版本库时，想要撤销本次提交，参考版本回退，不过前提是没有推送到远程库。 </p>
</li>
</ul>
<h2 id="标签管理"><a href="#标签管理" class="headerlink" title="标签管理"></a>标签管理</h2><h4 id="新建"><a href="#新建" class="headerlink" title="新建"></a>新建</h4><ul>
<li><p><code>git tag &lt;name&gt;</code>用于新建一个标签，默认标签是打在最新提交的commit上，也可以指定一个commit id；</p>
</li>
<li><p><code>git tag -a &lt;tagname&gt; -m &quot;blablabla...&quot;</code>可以指定标签信息；</p>
</li>
<li><p><code>git tag -s &lt;tagname&gt; -m &quot;blablabla...&quot;</code>可以用PGP签名标签；</p>
<h4 id="查看-1"><a href="#查看-1" class="headerlink" title="查看"></a>查看</h4></li>
<li><p><code>git tag</code>可以查看所有标签，<code>git show &lt;tagname&gt;</code> 查看标签所指向的提交</p>
<blockquote>
<p>例子</p>
</blockquote>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">`root@fan:/home/wwwroot/git/demo# git status</span><br><span class="line">位于分支 master</span><br><span class="line">无文件要提交，干净的工作区</span><br><span class="line">root@fan:/home/wwwroot/git/demo# git reflog</span><br><span class="line">7aca999 HEAD@&#123;0&#125;: commit: c</span><br><span class="line">a8e8e16 HEAD@&#123;1&#125;: commit: b</span><br><span class="line">9cab6a8 HEAD@&#123;2&#125;: commit (initial): a</span><br><span class="line">root@fan:/home/wwwroot/git/demo# clear</span><br><span class="line"></span><br><span class="line">root@fan:/home/wwwroot/git/demo# git tag &apos;cc&apos;</span><br><span class="line">root@fan:/home/wwwroot/git/demo# git tag</span><br><span class="line">cc</span><br><span class="line">root@fan:/home/wwwroot/git/demo# git reflog</span><br><span class="line">7aca999 HEAD@&#123;0&#125;: commit: c</span><br><span class="line">a8e8e16 HEAD@&#123;1&#125;: commit: b</span><br><span class="line">9cab6a8 HEAD@&#123;2&#125;: commit (initial): a</span><br><span class="line">root@fan:/home/wwwroot/git/demo# git show cc</span><br><span class="line">commit 7aca999821cd3384d634a7985782e8816d851d9b</span><br><span class="line">Author: fan \&lt;fan@qq.com\&gt;</span><br><span class="line">Date:   Wed Dec 7 21:08:35 2016 +0800</span><br><span class="line"></span><br><span class="line">c</span><br><span class="line"></span><br><span class="line">diff --git a/c b/c</span><br><span class="line">new file mode 100644</span><br><span class="line">index 0000000..f2ad6c7</span><br><span class="line">--- /dev/null</span><br><span class="line">+++ b/c</span><br><span class="line">@@ -0,0 +1 @@</span><br><span class="line">+c</span><br><span class="line">root@fan:/home/wwwroot/git/demo# git tag -a bb -m &apos;bbbbb&apos; a8e8e16</span><br><span class="line">root@fan:/home/wwwroot/git/demo# git tag</span><br><span class="line">bb</span><br><span class="line">cc</span><br><span class="line">root@fan:/home/wwwroot/git/demo# git show bb</span><br><span class="line">tag bb</span><br><span class="line">Tagger: fan \&lt;fan@qq.com\&gt;</span><br><span class="line">Date:   Wed Dec 7 21:09:52 2016 +0800</span><br><span class="line"></span><br><span class="line">bbbbb</span><br><span class="line"></span><br><span class="line">commit a8e8e16567a8c9adf06fe2778ee647250425451d</span><br><span class="line">Author: fan \&lt;fan@qq.com\&gt;</span><br><span class="line">Date:   Wed Dec 7 21:07:53 2016 +0800</span><br><span class="line"></span><br><span class="line">b</span><br><span class="line"></span><br><span class="line">diff --git a/b b/b</span><br><span class="line">new file mode 100644</span><br><span class="line">index 0000000..6178079</span><br><span class="line">--- /dev/null</span><br><span class="line">+++ b/b</span><br><span class="line">@@ -0,0 +1 @@</span><br><span class="line">+b</span><br></pre></td></tr></table></figure>
<p>`#### 推送标签到服务器</p>
<ul>
<li>推送单个标签<code>git push origin &lt;tagname&gt;</code></li>
<li>推送所有标签<code>git push origin --tags</code></li>
</ul>
<h4 id="删除服务器标签"><a href="#删除服务器标签" class="headerlink" title="删除服务器标签"></a>删除服务器标签</h4><ol>
<li><p>首先删除本地标签<code>git tag -d [tagname]</code></p>
</li>
<li><p>删除服务器上标签<code>git push origin :refs/tags/[tagname]</code></p>
<blockquote>
<p>例子</p>
</blockquote>
</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">`root@fan:/home/wwwroot/git/Demo# git pull</span><br><span class="line">Already up-to-date.</span><br><span class="line">root@fan:/home/wwwroot/git/Demo# git push origin --tags </span><br><span class="line">Total 0 (delta 0), reused 0 (delta 0)</span><br><span class="line">To git@git.coding.net:fan_code/Demo.git</span><br><span class="line"> - [new tag]()         1 -\&gt; 1</span><br><span class="line">	 - [new tag]()         2 -\&gt; 2</span><br><span class="line">	root@fan:/home/wwwroot/git/Demo# git tag -d 1</span><br><span class="line">	已删除标签 &apos;1&apos;（曾为 90a8fec）</span><br><span class="line">	root@fan:/home/wwwroot/git/Demo# git tag</span><br><span class="line">	2</span><br><span class="line">	root@fan:/home/wwwroot/git/Demo# git push origin :refs/tags/1</span><br><span class="line">	To git@git.coding.net:fan_code/Demo.git</span><br><span class="line">	- [deleted]()         1</span><br><span class="line">	`</span><br></pre></td></tr></table></figure>
<h1 id="lt-span-style-‘color-red’-分支管理-lt-span"><a href="#lt-span-style-‘color-red’-分支管理-lt-span" class="headerlink" title="\&lt;span style = ‘color:red’>分支管理 \&lt;/span>"></a>\&lt;span style = ‘color:red’>分支管理 \&lt;/span></h1><h4 id="工作场景"><a href="#工作场景" class="headerlink" title="工作场景"></a>工作场景</h4><p>假设此时，你突然接到一个电话说有个很严重的问题需要紧急修补，那么可以按照下面的方式处理：</p>
<ol>
<li>返回到原先已经发布到生产服务器上的分支。 </li>
<li>为这次紧急修补建立一个新分支，并在其中修复问题。 </li>
<li>通过测试后，回到生产服务器所在的分支，将修补分支合并进来，然后再推送到生产服务器上。 </li>
<li>切换到之前实现新需求的分支，继续工作。在切换回来之后，应该也把当前分支的bug修复</li>
</ol>
<h4 id="查看分支-git-branch-name"><a href="#查看分支-git-branch-name" class="headerlink" title="查看分支 git branch name"></a>查看分支 git branch <a href="">name</a></h4><ul>
<li><a href="">name</a> 是添加分支</li>
<li>-d <a href="">name</a> 删除干净的分支（假如分支中包含尚未合并进来的工作成果，则为不干净的分支）</li>
<li>-D <a href="">name</a> 强制删除</li>
<li>-v 查看各个分支最后一个提交对象的信息</li>
<li>–merged 查看哪些分支已被并入当前分支（也就是说哪些分支是当前分支的直接上游，如果有分支内容与当前分支内容一致，也会显示）</li>
<li>–no-merged 查看哪些分支未被并入当前分支<h4 id="切换分支-git-checkout-name"><a href="#切换分支-git-checkout-name" class="headerlink" title="切换分支 git checkout name"></a>切换分支 git checkout <a href="">name</a></h4><code>git checkout master</code>\&lt;br><br>它把 HEAD 指针移回到 master 分支，并把工作目录中的文件换成了 master 分支所指向的快照内容<h4 id="创建并切换分支-git-checkout-b-name"><a href="#创建并切换分支-git-checkout-b-name" class="headerlink" title="创建并切换分支 git checkout -b name"></a>创建并切换分支 git checkout -b <a href="">name</a></h4></li>
</ul>
<h4 id="合并分支到当前工作分支-git-merge-被合并的分支"><a href="#合并分支到当前工作分支-git-merge-被合并的分支" class="headerlink" title="合并分支到当前工作分支 git merge 被合并的分支"></a>合并分支到当前工作分支 git merge <a href="">被合并的分支</a></h4><p>分支合并分为：直接祖先合并、非直接祖先合并（会进行三方合并）</p>
<ol>
<li><p>直接祖先合并</p>
<ul>
<li>合并时出现了“Fast forward”的提示。由于当前 master 分支所在的提交对象是要并入的 hotfix 分支的直接上游，Git 只需把master 分支指针直接右移。换句话说，如果顺着一个分支走下去可以到达另一个分支的话，那么 Git 在合并两者时，只会简单地把指针右移，因为这种单线的历史分支不存在任何需要解决的分歧，所以这种合并过程可以称为快进（Fast forward）。</li>
</ul>
</li>
<li><p>非直接祖先合并（合并mster-c4和iss53->c5)</p>
<ul>
<li><ol>
<li>这次你的开发历史是从更早的地方开始分叉的。由于当前 master 分支所指向的提交对象（C4）并不是 iss53 分支的直接祖先，Git 不得不进行一些额外处理。就此例而言，Git 会用两个分支的末端（C4 和 C5）以及它们的共同祖先（C2）进行一次简单的三方合并计算。这次，Git 没有简单地把分支指针右移，而是对三方合并后的结果重新做一个新的快照，并自动创建一个指向它的提交对象（C6）。这个提交对象比较特殊，它有两个祖先（C4 和 C5）。</li>
</ol>
</li>
</ul>
</li>
</ol>
<h4 id="删除分支-git-branch-d-name"><a href="#删除分支-git-branch-d-name" class="headerlink" title="删除分支 git branch -d name"></a>删除分支 git branch -d <a href="">name</a></h4><h4 id="推送所有分支到远程仓库origin-git-push-origin-–all"><a href="#推送所有分支到远程仓库origin-git-push-origin-–all" class="headerlink" title="推送所有分支到远程仓库origin  git push origin –all"></a>推送所有分支到远程仓库origin  git push origin –all</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">`root@fan:/home/wwwroot/git/Demo# git push origin --all</span><br><span class="line">对象计数中: 3, 完成.</span><br><span class="line">压缩对象中: 100% (3/3), 完成.</span><br><span class="line">写入对象中: 100% (3/3), 280 bytes | 0 bytes/s, 完成.</span><br><span class="line">Total 3 (delta 2), reused 0 (delta 0)</span><br><span class="line">To git@git.coding.net:fan_code/Demo.git</span><br><span class="line"> - [new branch]()      dev -\&gt; dev</span><br><span class="line"> - [new branch]()      dev2 -\&gt; dev2</span><br><span class="line"> - [new branch]()      test -\&gt; test</span><br><span class="line">```		</span><br><span class="line">`</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">### 长期分支</span><br><span class="line"></span><br><span class="line">由于 Git 使用简单的三方合并，所以就算在较长一段时间内，反复多次把某个分支合并到另一分支，也不是什么难事。也就是说，你可以同时拥有多个开放的分支，每个分支用于完成特定的任务，随着开发的推进，你可以随时把某个特性分支的成果并到其他分支中。</span><br><span class="line"></span><br><span class="line">### 特性分支</span><br><span class="line"></span><br><span class="line">在任何规模的项目中都可以使用特性（Topic）分支。一个特性分支是指一个短期的，用来实现单一特性或与其相关工作的分支。可能你在以前的版本控 制系统里从未做过类似这样的事情，因为通常创建与合并分支消耗太大。然而在 Git 中，一天之内建立、使用、合并再删除多个分支是常见的事。</span><br><span class="line"></span><br><span class="line">### 远程分支</span><br><span class="line"></span><br><span class="line">远程分支（remote branch）是对远程仓库中的分支的索引。它们是一些无法移动的本地分支；只有在 Git 进行网络交互时才会更新。</span><br><span class="line">我们用 (远程仓库名)/(分支名) 这样的形式表示远程分支</span><br><span class="line">一次 Git 克隆会建立你自己的本地分支 master 和远程分支 origin/master，它们都指向 origin/master 分支的最后一次提交</span><br><span class="line"></span><br><span class="line">### 跟踪远程分支</span><br><span class="line"></span><br><span class="line">从远程分支 checkout 出来的本地分支，称为_跟踪分支(tracking branch)_。跟踪分支是一种和远程分支有直接联系的本地分支。在跟踪分支里输入git push，Git 会自行推断应该向哪个服务器的哪个分支推送数据。反过来，在这些分支里运行 git pull 会获取所有远程索引，并把它们的数据都合并到本地分支中来。</span><br><span class="line"></span><br><span class="line">在克隆仓库时，Git 通常会自动创建一个名为 master 的分支来跟踪 origin/master。这正是git push 和 git pull 一开始就能正常工作的原因。当然，你可以随心所欲地设定为其它跟踪分支，比如origin 上除了 master 之外的其它分支。刚才我们已经看到了这样的一个例子：git checkout -b [分支名]() [远程名]()/[分支名]()。如果你有 1.6.2 以上版本的 Git，还可以用--track 选项简化：</span><br></pre></td></tr></table></figure>
<p>`$ git checkout –track origin/serverfix<br>Branch serverfix set up to track remote branch refs/remotes/origin/serverfix.<br>Switched to a new branch “serverfix”<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">`要为本地分支设定不同于远程分支的名字，只需在前个版本的命令里换个名字：</span><br></pre></td></tr></table></figure></p>
<p>`$ git checkout -b sf origin/serverfix<br>Branch sf set up to track remote branch refs/remotes/origin/serverfix.<br>Switched to a new branch “sf”<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">`现在你的本地分支 sf 会自动向 origin/serverfix 推送和抓取数据了。</span><br><span class="line"></span><br><span class="line">### 删除远程分支</span><br><span class="line"></span><br><span class="line">如果不再需要某个远程分支了，比如搞定了某个特性并把它合并进了远程的 master 分支（或任何其他存放稳定代码的地方），可以用这个非常无厘头的语法来删除它：`git push [远程名] :[分支名]`。如果想在服务器上删除serverfix 分支，运行下面的命令：</span><br></pre></td></tr></table></figure></p>
<p>`$ git push origin :serverfix<br>To <a href="mailto:git@github.com" target="_blank" rel="noopener">git@github.com</a>:schacon/simplegit.git</p>
<ul>
<li><a href="">deleted</a>         serverfix<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">`有种方便记忆这条命令的方法：记住我们不久前见过的 `git push [远程名] [本地分支]:[远程分支]` 语法，如果省略 `[本地分支]`，那就等于是在说“在这里提取空白然后把它变成`[远程分支]`”。</span><br><span class="line"></span><br><span class="line">## 在服务器上部署 Git</span><br><span class="line"></span><br><span class="line">开始架设 Git 服务器前，需要先把现有仓库导出为裸仓库 — 即一个不包含当前工作目录的仓库。克隆时用 `--bare` 选项即可。裸仓库的目录名一般以`.git` 结尾，像这样：</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>`$ git clone –bare my_project my_project.git<br>Initialized empty Git repository in /opt/projects/my_project.git/<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">`</span><br><span class="line"></span><br><span class="line">有了裸仓库的副本后，剩下的就是把它放到服务器上并设定相关协议。假设一个域名为 `git.example.com` 的服务器已经架设好，并可以通过 SSH 访问，我们打算把所有 Git 仓库储存在/opt/git 目录下。只要把裸仓库复制过去：</span><br></pre></td></tr></table></figure></p>
<p>`$ scp -r my_project.git <a href="mailto:user@git.example.com" target="_blank" rel="noopener">user@git.example.com</a>:/opt/git<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">`现在，所有对该服务器有 SSH 访问权限，并可读取 /opt/git 目录的用户都可以用下面的命令克隆该项目：</span><br></pre></td></tr></table></figure></p>
<p>`$ git clone <a href="mailto:user@git.example.com" target="_blank" rel="noopener">user@git.example.com</a>:/opt/git/my_project.git<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">`如果某个 SSH 用户对 `/opt/git/my_project.git` 目录有写权限，那他就有推送权限。</span><br><span class="line">由此可见，根据现有的 Git 仓库创建一个裸仓库，然后把它放上你和同事都有 SSH 访问权的服务器是多么容易。现在已经可以开始在同一项目上密切合作了。</span><br><span class="line">这是架设一个少数人具有连接权的 Git 服务的全部 — 只要在服务器上加入可以用 SSH 登录的帐号，然后把裸仓库放在大家都有读写权限的地方。一切都准备停当，无需更多。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">### 小型安装</span><br><span class="line"></span><br><span class="line">如果设备较少或者你只想在小型开发团队里尝试 Git ，那么一切都很简单。架设 Git 服务最复杂的地方在于账户管理。如果需要仓库对特定的用户可读，而给另一部分用户读写权限，那么访问和许可的安排就比较困难。</span><br><span class="line">SSH 连接</span><br><span class="line"></span><br><span class="line">如果已经有了一个所有开发成员都可以用 SSH 访问的服务器，架设第一个服务器将变得异常简单，几乎什么都不用做（正如上节中介绍的那样）。如果需要对仓库进行更复杂的访问控制，只要使用服务器操作系统的本地文件访问许可机制就行了。</span><br><span class="line"></span><br><span class="line">&gt; 如果需要团队里的每个人都对仓库有写权限，又不能给每个人在服务器上建立账户，那么提供 SSH 连接就是唯一的选择了。我们假设用来共享仓库的服务器已经安装了 SSH 服务，而且你通过它访问服务器。</span><br><span class="line"></span><br><span class="line">有好几个办法可以让团队的每个人都有访问权。</span><br><span class="line">**第一个办法是给每个人建立一个账户，直截了当但略过繁琐。反复运行 adduser 并给所有人设定临时密码可不是好玩的。**</span><br><span class="line"></span><br><span class="line">**第二个办法是在主机上建立一个 git 账户，让每个需要写权限的人发送一个 SSH 公钥，然后将其加入 git 账户的/.ssh/authorizedkeys 文件。这样一来，所有人都将通过 git 账户访问主机。这丝毫不会影响提交的数据 — 访问主机用的身份不会影响提交对象的提交者信息。**</span><br><span class="line"></span><br><span class="line">**另一个办法是让 SSH 服务器通过某个 LDAP 服务，或者其他已经设定好的集中授权机制，来进行授权。只要每个人都能获得主机的 shell 访问权，任何可用的 SSH 授权机制都能达到相同效果。**</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line">#### 1. 生成 SSH 公钥</span><br><span class="line"></span><br><span class="line">大多数 Git 服务器都会选择使用 SSH 公钥来进行授权。系统中的每个用户都必须提供一个公钥用于授权，没有的话就要生成一个。生成公钥的过程在所有操作系统上都差不多。首先先确认一下是否已经有一个公钥了。SSH 公钥默认储存在账户的主目录下的/.ssh 目录。进去看看：</span><br></pre></td></tr></table></figure></p>
<p>`$ cd /.ssh<br>$ ls<br>authorized_keys2  id_dsa       known_hosts<br>config            id_dsa.pub<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">`关键是看有没有用 something 和 something.pub 来命名的一对文件，这个 something 通常就是 id_dsa 或 id_rsa。有 .pub 后缀的文件就是公钥，另一个文件则是密钥。假如没有这些文件，或者干脆连.ssh 目录都没有，可以用 ssh-keygen 来创建。该程序在 Linux/Mac 系统上由 SSH 包提供，而在 Windows 上则包含在 MSysGit 包里：</span><br></pre></td></tr></table></figure></p>
<p>`$ ssh-keygen<br>Generating public/private rsa key pair.<br>Enter file in which to save the key (/Users/schacon/.ssh/id_rsa):<br>Enter passphrase (empty for no passphrase):<br>Enter same passphrase again:<br>Your identification has been saved in /Users/schacon/.ssh/id_rsa.<br>Your public key has been saved in /Users/schacon/.ssh/id_rsa.pub.<br>The key fingerprint is:<br>43:c5:5b:5f:b1:f1:50:43:ad:20:a6:92:6a:1f:9a:3a <a href="mailto:schacon@agadorlaptop.local" target="_blank" rel="noopener">schacon@agadorlaptop.local</a><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">`它先要求你确认保存公钥的位置`（.ssh/id_rsa）`，然后它会让你重复一个密码两次，如果不想在使用公钥的时候输入密码，可以留空。</span><br><span class="line"></span><br><span class="line">现在，所有做过这一步的用户都得把它们的公钥给你或者 Git 服务器的管理员（假设 SSH 服务被设定为使用公钥机制）。他们只需要复制 .pub 文件的内容然后发邮件给管理员。公钥的样子大致如下：</span><br></pre></td></tr></table></figure></p>
<p>`$ cat /.ssh/idrsa.pub<br>ssh-rsa AAAAB3NzaC1yc2EAAAABIwAAAQEAklOUpkDHrfHY17SbrmTIpNLTGK9Tjom/BWDSU<br>GPl+nafzlHDTYW7hdI4yZ5ew18JH4JW9jbhUFrviQzM7xlELEVf4h9lFX5QVkbPppSwg0cda3<br>Pbv7kOdJ/MTyBlWXFCR+HAo3FXRitBqxiX1nKhXpHAZsMciLq8V6RjsNAQwdsdMFvSlVK/7XA<br>t3FaoJoAsncM1Q9x5+3V0Ww68/eIFmb1zuUFljQJKprrX88XypNDvjYNby6vw/Pb0rwert/En<br>mZ+AW4OZPnTPI89ZPmVMLuayrD2cE86Z/il8b+gw3r3+1nKatmIkjn2so1d01QraTlMqVSsbx<br>NrRFi9wrf+M7Q== <a href="mailto:schacon@agadorlaptop.local" target="_blank" rel="noopener">schacon@agadorlaptop.local</a><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">`关于在多个操作系统上设立相同 SSH 公钥的教程，可以查阅 GitHub 上有关 SSH 公钥的向导：http://github.com/guides/providing-your-ssh-key。</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line">#### 2. 架设服务器</span><br><span class="line"></span><br><span class="line">现在我们过一边服务器端架设 SSH 访问的流程。本例将使用 `authorized_keys` 方法来给用户授权。我们还将假定使用类似 Ubuntu 这样的标准 Linux 发行版。首先，创建一个名为 ‘git’ 的用户，并为其创建一个.ssh 目录。</span><br></pre></td></tr></table></figure></p>
<p>`$ sudo adduser git<br>$ su git<br>$ cd<br>$ mkdir .ssh<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">`接下来，把开发者的 SSH 公钥添加到这个用户的 authorized_keys 文件中。假设你通过电邮收到了几个公钥并存到了临时文件里。重复一下，公钥大致看起来是这个样子：</span><br></pre></td></tr></table></figure></p>
<p>`$ cat /tmp/id_rsa.john.pub<br>ssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAABAQCB007n/ww+ouN4gSLKssMxXnBOvf9LGt4L<br>ojG6rs6hPB09j9R/T17/x4lhJA0F3FR1rP6kYBRsWj2aThGw6HXLm9/5zytK6Ztg3RPKK+4k<br>Yjh6541NYsnEAZuXz0jTTyAUfrtU3Z5E003C4oxOj6H0rfIF1kKI9MAQLMdpGW1GYEIgS9Ez<br>Sdfd8AcCIicTDWbqLAcU4UpkaX8KyGlLwsNuuGztobF8m72ALC/nLF6JLtPofwFBlgc+myiv<br>O7TCUSBdLQlgMVOFq1I2uPWQOkOWQAHukEOmfjy2jctxSDBQ220ymjaNsHT4kgtZg2AYYgPq<br>dAv8JggJICUvax2T9va5 gsg-keypair<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">`只要把它们逐个追加到 authorized_keys 文件尾部即可：</span><br></pre></td></tr></table></figure></p>
<p>`$ cat /tmp/id_rsa.john.pub >> /.ssh/authorized_keys<br>$ cat /tmp/id_rsa.josie.pub >> /.ssh/authorized_keys<br>$ cat /tmp/id_rsa.jessica.pub >> /.ssh/authorized_keys<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">`现在可以用 --bare 选项运行 git init 来建立一个裸仓库，这会初始化一个不包含工作目录的仓库。</span><br></pre></td></tr></table></figure></p>
<p>`$ cd /opt/git<br>$ mkdir project.git<br>$ cd project.git<br>$ git –bare init<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">`这时，Join，Josie 或者 Jessica 就可以把它加为远程仓库，推送一个分支，从而把第一个版本的项目文件上传到仓库里了。值得注意的是，每次添加一个新项目都需要通过 shell 登入主机并创建一个裸仓库目录。我们不妨以gitserver 作为 git 用户及项目仓库所在的主机名。如果在网络内部运行该主机，并在 DNS 中设定 gitserver 指向该主机，那么以下这些命令都是可用的：</span><br></pre></td></tr></table></figure></p>
<p>`# 在 John 的电脑上<br>$ cd myproject<br>$ git init<br>$ git add .<br>$ git commit -m ‘initial commit’<br>$ git remote add origin git@gitserver:/opt/git/project.git<br>$ git push origin master<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">`这样，其他人的克隆和推送也一样变得很简单：</span><br></pre></td></tr></table></figure></p>
<p>`$ git clone git@gitserver:/opt/git/project.git<br>$ vim README<br>$ git commit -am ‘fix for the README file’<br>$ git push origin master<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">`用这个方法可以很快捷地为少数几个开发者架设一个可读写的 Git 服务。</span><br><span class="line"></span><br><span class="line">***作为一个额外的防范措施***，你可以用 Git 自带的 git-shell 工具限制 git 用户的活动范围。只要把它设为git 用户登入的 shell，那么该用户就无法使用普通的 bash 或者 csh 什么的 shell 程序。编辑 /etc/passwd 文件：</span><br></pre></td></tr></table></figure></p>
<p>`$ sudo vim /etc/passwd<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">`在文件末尾，你应该能找到类似这样的行：</span><br></pre></td></tr></table></figure></p>
<p>`git:x:1000:1000::/home/git:/bin/sh<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">`把 `bin/sh` 改为 `/usr/bin/git-shell `（或者用 which git-shell 查看它的实际安装路径）。该行修改后的样子如下：</span><br></pre></td></tr></table></figure></p>
<p>`git:x:1000:1000::/home/git:/usr/bin/git-shell<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">`现在 git 用户只能用 SSH 连接来推送和获取 Git 仓库，而不能直接使用主机 shell。尝试普通 SSH 登录的话，会看到下面这样的拒绝信息：</span><br></pre></td></tr></table></figure></p>
<p>`$ ssh git@gitserver<br>fatal: What do you think I am? A shell?<br>Connection to gitserver closed.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">`</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#### Gitosis 可以设置谁能读或者写哪个项目</span><br></pre></td></tr></table></figure></p>
<p>`把所有用户的公钥保存在 authorized_keys 文件的做法，只能凑和一阵子，当用户数量达到几百人的规模时，管理起来就会十分痛苦。每次改删用户都必须登录服务器不去说，这种做法还缺少必要的权限管理 — 每个人都对所有项目拥有完整的读写权限。</p>
<p>幸好我们还可以选择应用广泛的 Gitosis 项目。简单地说，Gitosis 就是一套用来管理 authorized_keys 文件和实现简单连接限制的脚本。有趣的是，用来添加用户和设定权限的并非通过网页程序，而只是管理一个特殊的 Git 仓库。你只需要在这个特殊仓库内做好相应的设定，然后推送到服务器上，Gitosis 就会随之改变运行策略，听起来就很酷，对吧？</p>
<p>Gitosis 的安装算不上傻瓜化，但也不算太难。用 Linux 服务器架设起来最简单 — 以下例子中，我们使用装有 Ubuntu 8.10 系统的服务器。</p>
<p>Gitosis 的工作依赖于某些 Python 工具，所以首先要安装 Python 的 setuptools 包，在 Ubuntu 上称为 python-setuptools：</p>
<p>$ apt-get install python-setuptools</p>
<p>接下来，从 Gitosis 项目主页克隆并安装：</p>
<p>$ git clone git://eagain.net/gitosis.git<br>$ cd gitosis<br>$ sudo python setup.py install</p>
<p>这会安装几个供 Gitosis 使用的工具。默认 Gitosis 会把 /home/git 作为存储所有 Git 仓库的根目录，这没什么不好，不过我们之前已经把项目仓库都放在/opt/git 里面了，所以为方便起见，我们可以做一个符号连接，直接划转过去，而不必重新配置：</p>
<p>$ ln -s /opt/git /home/git/repositories</p>
<p>Gitosis 将会帮我们管理用户公钥，所以先把当前控制文件改名备份，以便稍后重新添加，准备好让 Gitosis 自动管理 authorized_keys 文件：</p>
<p>$ mv /home/git/.ssh/authorized_keys /home/git/.ssh/ak.bak</p>
<p>接下来，如果之前把 git 用户的登录 shell 改为 git-shell 命令的话，先恢复 ‘git’ 用户的登录 shell。改过之后，大家仍然无法通过该帐号登录（译注：因为authorized_keys 文件已经没有了。），不过不用担心，这会交给 Gitosis 来实现。所以现在先打开 /etc/passwd 文件，把这行：</p>
<p>git:x:1000:1000::/home/git:/usr/bin/git-shell</p>
<p>改回:</p>
<p>git:x:1000:1000::/home/git:/bin/sh</p>
<p>好了，现在可以初始化 Gitosis 了。你可以用自己的公钥执行 gitosis-init 命令，要是公钥不在服务器上，先临时复制一份：</p>
<p>$ sudo -H -u git gitosis-init \&lt; /tmp/id_dsa.pub<br>Initialized empty Git repository in /opt/git/gitosis-admin.git/<br>Reinitialized existing Git repository in /opt/git/gitosis-admin.git/</p>
<p>这样该公钥的拥有者就能修改用于配置 Gitosis 的那个特殊 Git 仓库了。接下来，需要手工对该仓库中的 post-update 脚本加上可执行权限：</p>
<p>$ sudo chmod 755 /opt/git/gitosis-admin.git/hooks/post-update</p>
<p>基本上就算是好了。如果设定过程没出什么差错，现在可以试一下用初始化 Gitosis 的公钥的拥有者身份 SSH 登录服务器，应该会看到类似下面这样：</p>
<p>$ ssh git@gitserver<br>PTY allocation request failed on channel 0<br>fatal: unrecognized command ‘gitosis-serve schacon@quaternion’<br>  Connection to gitserver closed.</p>
<p>说明 Gitosis 认出了该用户的身份，但由于没有运行任何 Git 命令，所以它切断了连接。那么，现在运行一个实际的 Git 命令 — 克隆 Gitosis 的控制仓库：</p>
<h1 id="在你本地计算机上"><a href="#在你本地计算机上" class="headerlink" title="在你本地计算机上"></a>在你本地计算机上</h1><p>$ git clone git@gitserver:gitosis-admin.git</p>
<p>这会得到一个名为 gitosis-admin 的工作目录，主要由两部分组成：</p>
<p>$ cd gitosis-admin<br>$ find .<br>./gitosis.conf<br>./keydir<br>./keydir/scott.pub</p>
<p>gitosis.conf 文件是用来设置用户、仓库和权限的控制文件。keydir 目录则是保存所有具有访问权限用户公钥的地方— 每人一个。在keydir 里的文件名（比如上面的 scott.pub）应该跟你的不一样 — Gitosis 会自动从使用 gitosis-init 脚本导入的公钥尾部的描述中获取该名字。</p>
<p>看一下 gitosis.conf 文件的内容，它应该只包含与刚刚克隆的 gitosis-admin 相关的信息：</p>
<p>$ cat gitosis.conf<br><a href="">gitosis</a></p>
<p><a href="">group gitosis-admin</a><br>writable = gitosis-admin<br>members = scott</p>
<p>它显示用户 scott — 初始化 Gitosis 公钥的拥有者 — 是唯一能管理 gitosis-admin 项目的人。</p>
<p>现在我们来添加一个新项目。为此我们要建立一个名为 mobile 的新段落，在其中罗列手机开发团队的开发者，以及他们拥有写权限的项目。由于 ‘scott’ 是系统中的唯一用户，我们把他设为唯一用户，并允许他读写名为iphone_project 的新项目：</p>
<p><a href="">group mobile</a><br>writable = iphone_project<br>members = scott</p>
<p>修改完之后，提交 gitosis-admin 里的改动，并推送到服务器使其生效：</p>
<p>$ git commit -am ‘add iphone_project and mobile group’<br><a href="">master</a>: created 8962da8: “changed name”<br> 1 files changed, 4 insertions(+), 0 deletions(-)<br>$ git push<br>Counting objects: 5, done.<br>Compressing objects: 100% (2/2), done.<br>Writing objects: 100% (3/3), 272 bytes, done.<br>Total 3 (delta 1), reused 0 (delta 0)<br>To git@gitserver:/opt/git/gitosis-admin.git<br>   fb27aec..8962da8  master -> master</p>
<p>在新工程 iphone_project 里首次推送数据到服务器前，得先设定该服务器地址为远程仓库。但你不用事先到服务器上手工创建该项目的裸仓库— Gitosis 会在第一次遇到推送时自动创建：</p>
<p>$ git remote add origin git@gitserver:iphone_project.git<br>$ git push origin master<br>Initialized empty Git repository in /opt/git/iphone_project.git/<br>Counting objects: 3, done.<br>Writing objects: 100% (3/3), 230 bytes, done.<br>Total 3 (delta 0), reused 0 (delta 0)<br>To git@gitserver:iphone_project.git</p>
<ul>
<li><a href="">new branch</a>      master -> master</li>
</ul>
<p>请注意，这里不用指明完整路径（实际上，如果加上反而没用），只需要一个冒号加项目名字即可 — Gitosis 会自动帮你映射到实际位置。</p>
<p>要和朋友们在一个项目上协同工作，就得重新添加他们的公钥。不过这次不用在服务器上一个一个手工添加到 /.ssh/authorizedkeys 文件末端，而只需管理keydir 目录中的公钥文件。文件的命名将决定在 gitosis.conf 中对用户的标识。现在我们为 John，Josie 和 Jessica 添加公钥：</p>
<p>$ cp /tmp/id_rsa.john.pub keydir/john.pub<br>$ cp /tmp/id_rsa.josie.pub keydir/josie.pub<br>$ cp /tmp/id_rsa.jessica.pub keydir/jessica.pub</p>
<p>然后把他们都加进 ‘mobile’ 团队，让他们对 iphone_project 具有读写权限：</p>
<p><a href="">group mobile</a><br>writable = iphone_project<br>members = scott john josie jessica</p>
<p>如果你提交并推送这个修改，四个用户将同时具有该项目的读写权限。</p>
<p>Gitosis 也具有简单的访问控制功能。如果想让 John 只有读权限，可以这样做：</p>
<p><a href="">group mobile</a><br>writable = iphone_project<br>members = scott josie jessica</p>
<p><a href="">group mobile_ro</a><br>readonly = iphone_project<br>members = john</p>
<p>现在 John 可以克隆和获取更新，但 Gitosis 不会允许他向项目推送任何内容。像这样的组可以随意创建，多少不限，每个都可以包含若干不同的用户和项目。甚至还可以指定某个组为成员之一（在组名前加上@ 前缀），自动继承该组的成员：</p>
<p><a href="">group mobile_committers</a><br>members = scott josie jessica</p>
<p><a href="">group mobile</a><br>writable  = iphone_project<br>members   = @mobile_committers</p>
<p><a href="">group mobile_2</a><br>writable  = another_iphone_project<br>members   = @mobile_committers john</p>
<p>如果遇到意外问题，试试看把 loglevel=DEBUG 加到 <a href="">gitosis</a> 的段落（译注：把日志设置为调试级别，记录更详细的运行信息。）。如果一不小心搞错了配置，失去了推送权限，也可以手工修改服务器上的/home/git/.gitosis.conf 文件 — Gitosis 实际是从该文件读取信息的。它在得到推送数据时，会把新的 gitosis.conf 存到该路径上。所以如果你手工编辑该文件的话，它会一直保持到下次向 gitosis-admin 推送新版本的配置内容为止。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">`## 工作流程</span><br><span class="line">#### 提交规范</span><br><span class="line">请将每次提交限定于完成一次逻辑功能。并且可能的话，适当地分解为多次小更新，以便每次小型提交都更易于理解。请不要在周末穷追猛打一次性 解决五个问题，而最后拖到周一再提交。就算是这样也请尽可能利用暂存区域，将之前的改动分解为每次修复一个问题，再分别提交和加注说明。如果针对两个问题 改动的是同一个文件，可以试试看git add --patch 的方式将部分内容置入暂存区域（我们会在第六章再详细介绍）。无论是五次小提交还是混杂在一起的大提交，最终分支末端的项目快照应该还是一样的，但分解开 来之后，更便于其他开发者复阅。这么做也方便自己将来取消某个特定问题的修复。我们将在第六章介绍一些重写提交历史，同暂存区域交互的技巧和工具，以便最 终得到一个干净有意义，且易于理解的提交历史</span><br><span class="line"></span><br><span class="line">最后需要谨记的是提交说明的撰写。写得好可以让大家协作起来更轻松。一般来说，提交说明最好限制在一行以内，50 个字符以下，简明扼要地描述更新内容，空开一行后，再展开详细注解。Git 项目本身需要开发者撰写详尽注解，包括本次修订的因由，以及前后不同实现之间的比较，我们也该借鉴这种做法</span><br><span class="line">&gt; 例如</span><br></pre></td></tr></table></figure></p>
<p>`本次更新的简要描述（50 个字符以内）</p>
<p>如果必要，此处展开详尽阐述。段落宽度限定在 72 个字符以内。<br>某些情况下，第一行的简要描述将用作邮件标题，其余部分作为邮件正文。<br>其间的空行是必要的，以区分两者（当然没有正文另当别论）。<br>如果并在一起，rebase 这样的工具就可能会迷惑。</p>
<p>另起空行后，再进一步补充其他说明。</p>
<ul>
<li><p>可以使用这样的条目列举式。</p>
</li>
<li><p>一般以单个空格紧跟短划线或者星号作为每项条目的起始符。每个条目间用一空行隔开。<br>不过这里按自己项目的约定，可以略作变化。<br><code>`</code><br>`</p>
<ul>
<li><p>工作流程</p>
<p>最简单的协作方式之一：先在自己的特性分支中工作一段时间，完成后合并到自己的 master 分支；然后下载合并 origin/master 上的更新（如果有的话），再推回远程服务器。</p>
</li>
</ul>
</li>
</ul>
</div><div class="tags"></div><div class="post-nav"><a class="pre" href="/2017/05/10/es6 中变量解构赋值的用途/"></a><a class="next" href="/2017/02/06/mac下搭建nginx-memcache-mysql-php环境/">mac 搭建 php环境</a></div></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">Copyright © 2018 <a href="/." rel="nofollow">Imfan.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div></div></div><a class="show" id="rocket" href="#top"></a><script type="text/javascript" src="/js/totop.js?v=0.0.0" async></script><script type="text/javascript" src="/js/jquery.fancybox.min.js" async></script><script type="text/javascript" src="/js/fancybox.js?v=0.0.0" async></script><link rel="stylesheet" type="text/css" href="/css/jquery.fancybox.min.css"><script type="text/javascript" src="/js/codeblock-resizer.js?v=0.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=0.0.0"></script></div></body></html>