<!DOCTYPE html><html><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description"><title>GO 需要注意的地方 | Imfan</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=0.0.0"><link rel="stylesheet" type="text/css" href="/css/normalize.min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/1.0.0/pure-min.css"><link rel="stylesheet" type="text/css" href="/css/grids-responsive-min.css"><link rel="stylesheet" href="/css/font-awesome.min.css"><script type="text/javascript" src="/js/jquery.3.3.1.min.js"></script><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">GO 需要注意的地方</h1><a id="logo" href="/.">Imfan</a><p class="description"></p></div><div id="nav-menu"><a class="current" href="/."><i class="fa fa-home"> Start</i></a><a href="/archives/"><i class="fa fa-archive"> Archiv</i></a><a href="/about/"><i class="fa fa-user"> Über</i></a><a href="/atom.xml"><i class="fa fa-rss"> RSS</i></a></div></div><div class="pure-g" id="layout"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">GO 需要注意的地方</h1><div class="post-meta">Oct 17, 2018</div><div class="clear"><div class="toc-article" id="toc"><div class="toc-title">目录</div><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#文件名、关键字、标识符"><span class="toc-number">1.</span> <span class="toc-text">文件名、关键字、标识符</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Go-程序的基本结构和要素"><span class="toc-number">2.</span> <span class="toc-text">Go 程序的基本结构和要素</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#可见性规则"><span class="toc-number">2.1.</span> <span class="toc-text">可见性规则</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#对引入的包使用别名"><span class="toc-number">2.2.</span> <span class="toc-text">对引入的包使用别名</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#数据类型"><span class="toc-number">3.</span> <span class="toc-text">数据类型</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#float类型"><span class="toc-number">3.1.</span> <span class="toc-text">float类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#字符串"><span class="toc-number">3.2.</span> <span class="toc-text">字符串</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#函数需要注意的"><span class="toc-number">4.</span> <span class="toc-text">函数需要注意的</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#大括号的使用"><span class="toc-number">4.1.</span> <span class="toc-text">大括号的使用</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#类型转换"><span class="toc-number">5.</span> <span class="toc-text">类型转换</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#数据类型别名"><span class="toc-number">5.1.</span> <span class="toc-text">数据类型别名</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#常量"><span class="toc-number">6.</span> <span class="toc-text">常量</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#变量的声明"><span class="toc-number">7.</span> <span class="toc-text">变量的声明</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#运算符"><span class="toc-number">8.</span> <span class="toc-text">运算符</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#布尔值"><span class="toc-number">8.1.</span> <span class="toc-text">布尔值</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#位运算"><span class="toc-number">8.2.</span> <span class="toc-text">位运算</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#函数"><span class="toc-number">9.</span> <span class="toc-text">函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#内置函数"><span class="toc-number">10.</span> <span class="toc-text">内置函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#数组"><span class="toc-number">11.</span> <span class="toc-text">数组</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#将数组传递给函数-优化方式"><span class="toc-number">11.1.</span> <span class="toc-text">将数组传递给函数 优化方式</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#切片"><span class="toc-number">12.</span> <span class="toc-text">切片</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#切片在内存中的存储结构"><span class="toc-number">12.1.</span> <span class="toc-text">切片在内存中的存储结构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#new-和-make-的区别"><span class="toc-number">12.2.</span> <span class="toc-text">new() 和 make() 的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#append-函数常见操作"><span class="toc-number">12.3.</span> <span class="toc-text">append 函数常见操作</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#map"><span class="toc-number">13.</span> <span class="toc-text">map</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#map-操作"><span class="toc-number">13.1.</span> <span class="toc-text">map 操作</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#判断是否存在"><span class="toc-number">13.1.1.</span> <span class="toc-text">判断是否存在</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#删除"><span class="toc-number">13.1.2.</span> <span class="toc-text">删除</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#使用-函数func-int-作为值的-map："><span class="toc-number">13.2.</span> <span class="toc-text">使用 函数func() int 作为值的 map：</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#结构体"><span class="toc-number">14.</span> <span class="toc-text">结构体</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#结构体不同实例化方式-内存布局"><span class="toc-number">14.1.</span> <span class="toc-text">结构体不同实例化方式 内存布局</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#结构体的实例化及方法的调用"><span class="toc-number">14.2.</span> <span class="toc-text">结构体的实例化及方法的调用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#map-、struct-和-new-、-make-需要注意的地方"><span class="toc-number">14.3.</span> <span class="toc-text">map 、struct 和 new() 、 make()需要注意的地方</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#匿名字段和内嵌结构体"><span class="toc-number">14.4.</span> <span class="toc-text">匿名字段和内嵌结构体</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#命名冲突"><span class="toc-number">14.5.</span> <span class="toc-text">命名冲突</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#方法"><span class="toc-number">14.6.</span> <span class="toc-text">方法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#结构体上的简单方法的例子："><span class="toc-number">14.6.1.</span> <span class="toc-text">结构体上的简单方法的例子：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#非结构体类型上方法的例子："><span class="toc-number">14.6.2.</span> <span class="toc-text">非结构体类型上方法的例子：</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#接口"><span class="toc-number">15.</span> <span class="toc-text">接口</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#在接口上调用方法时，必须有和方法定义时相同的接收者类型或者是可以从具体类型-P-直接可以辨识的"><span class="toc-number">15.1.</span> <span class="toc-text">在接口上调用方法时，必须有和方法定义时相同的接收者类型或者是可以从具体类型 P 直接可以辨识的</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#类型断言：如何检测和转换接口变量的类型"><span class="toc-number">15.2.</span> <span class="toc-text">类型断言：如何检测和转换接口变量的类型</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#示例"><span class="toc-number">15.2.1.</span> <span class="toc-text">示例</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#type-switch"><span class="toc-number">15.2.2.</span> <span class="toc-text">type-switch</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#复制数据切片至空接口切片"><span class="toc-number">15.3.</span> <span class="toc-text">复制数据切片至空接口切片</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#反射"><span class="toc-number">15.4.</span> <span class="toc-text">反射</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#通过反射修改-设置-值"><span class="toc-number">15.4.1.</span> <span class="toc-text">通过反射修改(设置)值</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#GO中的面向对象"><span class="toc-number">15.5.</span> <span class="toc-text">GO中的面向对象</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#读写数据"><span class="toc-number">16.</span> <span class="toc-text">读写数据</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#文件读"><span class="toc-number">16.1.</span> <span class="toc-text">文件读</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#文件写"><span class="toc-number">16.2.</span> <span class="toc-text">文件写</span></a></li></ol></li></ol></div></div><div class="post-content"><p>GO 需要注意的地方<br><a id="more"></a></p>
<h2 id="文件名、关键字、标识符"><a href="#文件名、关键字、标识符" class="headerlink" title="文件名、关键字、标识符"></a>文件名、关键字、标识符</h2><p><code>_</code> 本身就是一个特殊的标识符，被称为空白标识符。它可以像其他标识符那样用于变量的声明或赋值（任何类型都可以赋值给它），但任何赋给这个标识符的值都将被抛弃，因此这些值不能在后续的代码中使用，也不可以使用这个标识符作为变量对其它变量进行赋值或运算。</p>
<h2 id="Go-程序的基本结构和要素"><a href="#Go-程序的基本结构和要素" class="headerlink" title="Go 程序的基本结构和要素"></a>Go 程序的基本结构和要素</h2><ol>
<li>在完成包的 <code>import</code> 之后，开始对常量、变量和类型的定义或声明。</li>
<li>如果存在 <code>init</code> 函数的话，则对该函数进行定义（这是一个特殊的函数，每个含有该函数的包都会首先执行这个函数）。</li>
<li>如果当前包是 <code>main</code> 包，则定义 <code>main</code> 函数。</li>
<li>然后定义其余的函数，首先是类型的方法，接着是按照 <code>main</code> 函数中先后调用的顺序来定义相关函数，<strong>如果有很多函数，则可以按照字母顺序来进行排序</strong>。</li>
</ol>
<ul>
<li>所有的包名都应该使用小写字母。</li>
<li>除了符号 <code>_</code>，包中所有代码对象的标识符必须是唯一的，以避免名称冲突。但是相同的标识符可以在不同的包中使用，因为可以使用包名来区分它们。</li>
<li>空白标识符 <code>_</code> 也被用于抛弃值，如值 <code>5</code> 在：<code>_, b = 5, 7</code> 中被抛弃。<code>_</code> 实际上是一个只写变量，你不能得到它的值。这样做是因为 Go 语言中你必须使用所有被声明的变量，但有时你并不需要使用从一个函数得到的所有返回值。</li>
</ul>
<h3 id="可见性规则"><a href="#可见性规则" class="headerlink" title="可见性规则"></a>可见性规则</h3><ul>
<li>当标识符（包括常量、变量、类型、函数名、结构字段等等）<strong>以一个大写字母开头</strong>，如：<code>Group1</code>，那么使用这种形式的标识符的对象就<strong>可以被外部包的代码所使用</strong>（客户端程序需要先导入这个包），这被称为导出（像面向对象语言中的 <code>public</code>）</li>
<li>标识符如果以小写字母开头，则对包外是不可见的，但是他们在整个包的内部是可见并且可用的（像面向对象语言中的 <code>private</code> ）。</li>
</ul>
<h3 id="对引入的包使用别名"><a href="#对引入的包使用别名" class="headerlink" title="对引入的包使用别名"></a>对引入的包使用别名</h3><p>你可以通过使用包的别名来解决包名之间的名称冲突，或者说根据你的个人喜好对包名进行重新设置，如：<code>import fm &quot;fmt&quot;</code>。下面的代码展示了如何使用包的别名：</p>
<p>示例 <code>alias.go</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import fm &quot;fmt&quot; // alias3</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">   fm.Println(&quot;hello, world&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><h3 id="float类型"><a href="#float类型" class="headerlink" title="float类型"></a>float类型</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// floattest 默认声明为 float64</span><br><span class="line">flottest := 1.1</span><br></pre></td></tr></table></figure>
<h3 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h3><p>字符串是纯粹不可变的字节数组，它们也可以被切分成 切片。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">b := <span class="string">"imfan"</span></span><br><span class="line">sli := b[:<span class="number">3</span>]</span><br><span class="line">fmt.Println(sli)</span><br></pre></td></tr></table></figure>
<h2 id="函数需要注意的"><a href="#函数需要注意的" class="headerlink" title="函数需要注意的"></a>函数需要注意的</h2><ul>
<li><code>main</code> 函数是每一个可执行程序所必须包含的，一般来说都是在启动后第一个执行的函数（如果有 <code>init()</code>函数则会先执行该函数）。</li>
<li><code>main</code> 函数既没有参数，也没有返回类型。如果你不小心为 <code>main</code> 函数添加了参数或者返回类型，将会引发构建错误：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">func main must have no arguments and no return values results.</span><br></pre></td></tr></table></figure>
<h3 id="大括号的使用"><a href="#大括号的使用" class="headerlink" title="大括号的使用"></a>大括号的使用</h3><p>左大括号<code>{</code> 必须与方法的声明放在同一行，这是编译器的强制规定</p>
<h2 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h2><p><code>Go</code> 语言不存在隐式类型转换，因此所有的转换都必须显式说明，就像调用一个函数一样（类型在这里的作用可以看作是一种函数）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">valueOfTypeB = typeB(valueOfTypeA)</span><br></pre></td></tr></table></figure>
<p><code>类型 B 的值 = 类型 B(类型 A 的值)</code></p>
<p>比如</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a := 5.0</span><br><span class="line">b := int(a)</span><br></pre></td></tr></table></figure>
<h3 id="数据类型别名"><a href="#数据类型别名" class="headerlink" title="数据类型别名"></a>数据类型别名</h3><p>几何点（或者数学向量）是一个使用数组的经典例子。为了简化代码通常使用一个别名：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">type Vector3D [3]float32</span><br><span class="line">var vec Vector3D</span><br></pre></td></tr></table></figure>
<h2 id="常量"><a href="#常量" class="headerlink" title="常量"></a>常量</h2><p>常量使用关键字 <code>const</code> 定义，用于存储不会改变的数据。</p>
<p>存储在常量中的数据类型只可以是<code>布尔型</code>、<code>数字型</code>（整数型、浮点型和复数）和<code>字符串型</code>。<br>在编译期间自定义函数均属于未知，因此无法用于常量的赋值，但内置函数可以使用，如：<code>len()</code>。</p>
<h2 id="变量的声明"><a href="#变量的声明" class="headerlink" title="变量的声明"></a>变量的声明</h2><p>将它们都声明为指针类型：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a, b *<span class="keyword">int</span></span><br></pre></td></tr></table></figure>
<p>声明多个变量类型</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> (</span><br><span class="line">    a <span class="keyword">int</span></span><br><span class="line">    b <span class="keyword">bool</span></span><br><span class="line">    str <span class="keyword">string</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<p>当你在函数体内声明局部变量时，应使用简短声明语法 <code>:=</code>，例如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a := 1</span><br></pre></td></tr></table></figure>
<p>当一个变量被声明之后，系统自动赋予它该类型的零值：<code>int</code> 为 0，<code>float</code> 为 0.0，<code>bool</code> 为 false，<code>string</code> 为空字符串，指针为 <code>nil</code>。记住，所有的内存在 Go 中都是经过初始化的。</p>
<ul>
<li>一般情况下，当变量a和变量b之间类型相同时，才能进行如<code>a = b</code>的赋值。</li>
</ul>
<h2 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h2><p><code>Go</code> 对于值之间的比较有非常严格的限制，只有两个类型相同的值才可以进行比较，如果值的类型是接口<code>（interface）</code>，它们也必须都实现了相同的接口</p>
<p><code>&amp;&amp;</code> 和 <code>||</code> 是具有快捷性质的运算符，如果你有多个条件判断，应当将计算过程较为复杂的表达式放在运算符的右侧以减少不必要的运算。</p>
<h3 id="布尔值"><a href="#布尔值" class="headerlink" title="布尔值"></a>布尔值</h3><p>在格式化输出时，你可以使用<code>%t</code>来表示你要输出的值为布尔型。</p>
<h3 id="位运算"><a href="#位运算" class="headerlink" title="位运算"></a>位运算</h3><p>位运算只能用于整数类型的变量，且需当它们拥有等长位模式时。</p>
<p><code>%b</code> 是用于表示位的格式化标识符。</p>
<h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><p>尽量使用命名返回值：会使代码更清晰、更简短，同时更加容易读懂。</p>
<h2 id="内置函数"><a href="#内置函数" class="headerlink" title="内置函数"></a>内置函数</h2><table>
<thead>
<tr>
<th>函数名</th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td>close</td>
<td>用于管道通信</td>
</tr>
<tr>
<td>len、cap</td>
<td>len 用于返回某个类型的长度或数量（字符串、数组、切片、map 和管道）；cap 是容量的意思，用于返回某个类型的最大容量（只能用于切片和 map）</td>
</tr>
<tr>
<td>new、make</td>
<td>new 和 make 均是用于分配内存：new 用于值类型和用户定义的类型，如自定义结构，make 用于内置引用类型（切片、map 和管道）。它们的用法就像是函数，但是将类型作为参数：new(type)、make(type)。new(T) 分配类型 T 的零值并返回其地址，也就是指向类型 T 的指针（详见第 10.1 节）。它也可以被用于基本类型：v := new(int)。make(T) 返回类型 T 的初始化之后的值，因此它比 new 进行更多的工作（详见第 7.2.3/4 节、第 8.1.1 节和第 14.2.1 节）new() 是一个函数，不要忘记它的括号</td>
</tr>
<tr>
<td>copy、append</td>
<td>用于复制和连接切片</td>
</tr>
<tr>
<td>panic、recover</td>
<td>两者均用于错误处理机制</td>
</tr>
<tr>
<td>print、println</td>
<td>底层打印函数（详见第 4.2 节），在部署环境中建议使用 fmt 包</td>
</tr>
<tr>
<td>complex、real imag</td>
<td>用于创建和操作复数（详见第 4.5.2.2 节）</td>
</tr>
</tbody>
</table>
<h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><ul>
<li>数组长度也是数组类型的一部分，所以<code>[5]int</code>和<code>[10]int</code>是属于不同类型的</li>
<li><p>编译时需要知道数组长度以便分配内存，数组长度最大为 <code>2Gb</code></p>
</li>
<li><p><code>Go</code> 语言中的数组是一种 值类型，所以可以通过 <code>new()</code> 来创建： <code>var arr1 = new([5]int)</code>。<br>那么这种方式和 <code>var arr2 [5]int</code> 的区别是什么呢？<br><code>arr1</code> 的类型是 <code>*[5]int</code>，而 <code>arr2</code>的类型是 <code>[5]int</code>。<br>这样的结果就是当把一个数组赋值给另一个时，需要再做一次数组内存的拷贝操作。例如：</p>
</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">arr2 := *arr1</span><br><span class="line">arr2[<span class="number">2</span>] = <span class="number">100</span></span><br></pre></td></tr></table></figure>
<p>这样两个数组就有了不同的值，在赋值后修改 <code>arr2</code> 不会对 <code>arr1</code> 生效。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">arr1 := <span class="built_in">new</span>([<span class="number">5</span>]<span class="keyword">int</span>)</span><br><span class="line">arr1[<span class="number">1</span>] = <span class="number">1</span></span><br><span class="line"><span class="comment">// 将指针赋给brr,改变brr值会改变arr1的值</span></span><br><span class="line"><span class="comment">//brr := arr1</span></span><br><span class="line"><span class="comment">// 拷贝一份赋值给brr</span></span><br><span class="line">brr := *arr1</span><br><span class="line">brr[<span class="number">1</span>] = <span class="number">2</span></span><br><span class="line"><span class="built_in">println</span>(brr[<span class="number">1</span>])</span><br><span class="line"><span class="built_in">println</span>(arr1[<span class="number">1</span>])</span><br></pre></td></tr></table></figure>
<h3 id="将数组传递给函数-优化方式"><a href="#将数组传递给函数-优化方式" class="headerlink" title="将数组传递给函数 优化方式"></a>将数组传递给函数 优化方式</h3><p>把一个大数组传递给函数会消耗很多内存。有两种方法可以避免这种现象：</p>
<ul>
<li>传递数组的指针</li>
<li>使用数组的切片</li>
</ul>
<ol>
<li>传递数组的指针</li>
</ol>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    array := [<span class="number">3</span>]<span class="keyword">float64</span>&#123;<span class="number">7.0</span>, <span class="number">8.5</span>, <span class="number">9.1</span>&#125;</span><br><span class="line">    x := Sum(&amp;array) <span class="comment">// Note the explicit address-of operator</span></span><br><span class="line">    <span class="comment">// to pass a pointer to the array</span></span><br><span class="line">    fmt.Printf(<span class="string">"The sum of the array is: %f"</span>, x)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Sum</span><span class="params">(a *[3]<span class="keyword">float64</span>)</span> <span class="params">(sum <span class="keyword">float64</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> _, v := <span class="keyword">range</span> a &#123; <span class="comment">// derefencing *a to get back to the array is not necessary!</span></span><br><span class="line">        sum += v</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>使用切片<br>把数组分片，创建为一个 切片引用并传递给该函数。这里有一个计算数组元素和的方法:</li>
</ol>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sum</span><span class="params">(a []<span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    s := <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(a); i++ &#123;</span><br><span class="line">        s += a[i]</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> s</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> arr = [<span class="number">5</span>]<span class="keyword">int</span>&#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;</span><br><span class="line">    sum(arr[:])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="切片"><a href="#切片" class="headerlink" title="切片"></a>切片</h2><p>切片（<code>slice</code>）是对数组一个连续片段的<strong>引用</strong>.<br><code>cap()</code> 可以测量切片最长可以达到多少：它等于切片的长度 + 数组除切片之外的长度。<br>对于 切片 <code>s</code> 来说该不等式永远成立：<code>0 &lt;= len(s) &lt;= cap(s)</code>。</p>
<p><strong>注意</strong> 绝对不要用指针指向 <code>slice</code>。切片本身已经是一个引用类型，所以它本身就是一个指针!</p>
<ul>
<li>获取字母的<code>ascii</code>码值</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">b := []<span class="keyword">byte</span>&#123;<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>, <span class="string">'d'</span>, <span class="string">'e'</span>, <span class="string">'f'</span>&#125;</span><br><span class="line">	fmt.Println(b[<span class="number">1</span>:<span class="number">4</span>])</span><br></pre></td></tr></table></figure>
<h3 id="切片在内存中的存储结构"><a href="#切片在内存中的存储结构" class="headerlink" title="切片在内存中的存储结构"></a>切片在内存中的存储结构</h3><p>切片在内存中的组织方式实际上是一个有 <code>3</code> 个域的结构体：</p>
<ol>
<li>指向相关数组的指针</li>
<li>切片长度</li>
<li>切片容量。<br>下图给出了一个长度为 <code>2</code>，容量为 <code>4</code> 的切片<code>y</code>。</li>
</ol>
<p><img src="http://pgqbhubpz.bkt.clouddn.com/2018-10-17-15353531907679.jpg" alt=""></p>
<h3 id="new-和-make-的区别"><a href="#new-和-make-的区别" class="headerlink" title="new() 和 make() 的区别"></a><code>new()</code> 和 <code>make()</code> 的区别</h3><p>看起来二者没有什么区别，都在堆上分配内存，但是它们的行为不同，适用于不同的类型。</p>
<p><code>new(T)</code> 为每个新的类型T分配一片内存，初始化为 零值 并且返回类型为<code>*T</code>的内存地址：这种方法 返回一个指向类型为 <code>T</code>，值为 <code>0</code> 的地址的指针，它适用于值类型如数组和结构体；它相当于 <code>&amp;T{}</code>。<br><code>make(T)</code> 返回一个类型为 <code>T</code> 的初始值，它只适用于<code>3</code>种内建的引用类型：<strong>切片、<code>map</code> 和 <code>channel</code></strong>。<br><strong>换言之，<code>new</code> 函数分配内存，<code>make</code> 函数初始化；下图给出了区别：</strong></p>
<p><img src="http://pgqbhubpz.bkt.clouddn.com/2018-10-17-15355410073741.jpg" alt=""></p>
<h3 id="append-函数常见操作"><a href="#append-函数常见操作" class="headerlink" title="append 函数常见操作"></a>append 函数常见操作</h3><ul>
<li>将切片 <code>b</code> 的元素追加到切片 <code>a</code> 之后：<code>a = append(a, b...)</code></li>
<li>复制切片 <code>a</code> 的元素到新的切片 <code>b</code> 上：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">b = make([]T, len(a))</span><br><span class="line">copy(b, a)</span><br></pre></td></tr></table></figure>
<ul>
<li>删除位于索引 <code>i</code> 的元素：<code>a = append(a[:i], a[i+1:]...)</code></li>
<li>切除切片 <code>a</code> 中从索引 <code>i</code> 至 <code>j</code> 位置的元素：<code>a = append(a[:i], a[j:]...)</code></li>
<li>为切片 <code>a</code> 扩展 <code>j</code> 个元素长度：<code>a = append(a, make([]T, j)...)</code></li>
<li>在索引 <code>i</code> 的位置插入元素 <code>x</code>：<code>a = append(a[:i], append([]T{x}, a[i:]...)...)</code></li>
<li>在索引 <code>i</code> 的位置插入长度为 <code>j</code> 的新切片：<code>a = append(a[:i], append(make([]T, j), a[i:]...)...)</code></li>
<li>在索引 <code>i</code> 的位置插入切片 <code>b</code> 的所有元素：<code>a = append(a[:i], append(b, a[i:]...)...)</code></li>
<li>取出位于切片 <code>a</code> 最末尾的元素 <code>x</code>：<code>x, a = a[len(a)-1], a[:len(a)-1]</code></li>
<li>将元素 <code>x</code> 追加到切片 <code>a：a = append(a, x)</code></li>
</ul>
<h2 id="map"><a href="#map" class="headerlink" title="map"></a>map</h2><p><code>map</code> 是 <strong>引用类型</strong> 的： 内存用 <code>make</code> 方法来分配。<strong>不要使用 <code>new</code>，永远用 <code>make</code> 来构造 <code>map</code></strong><br>可以使用如下声明：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> map1 <span class="keyword">map</span>[keytype]valuetype</span><br><span class="line"><span class="keyword">var</span> map1 <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">int</span></span><br><span class="line"></span><br><span class="line">mp1 := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">int</span>][]<span class="keyword">int</span>)</span><br><span class="line">mp2 := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">int</span>]*[]<span class="keyword">int</span>)</span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>注意</strong> 如果你错误的使用 <code>new()</code> 分配了一个引用对象，你会获得一个空引用的指针，相当于声明了一个未初始化的变量并且取了它的地址：</p>
</blockquote>
<ul>
<li><p>未初始化的 <code>map</code> 的值是 <code>nil</code>。</p>
</li>
<li><p><code>key</code> 可以是任意可以用 <code>==</code> 或者 <code>!=</code> 操作符比较的类型，比如 <code>string、int、float</code>。所以数组、切片和结构体不能作为 <code>key</code> (含有数组切片的结构体不能作为 <code>key</code>，只包含内建类型的 <code>struct</code> 是可以作为 <code>key</code> 的），但是指针和接口类型可以。如果要用结构体作为 <code>key</code> 可以提供 <code>Key()</code> 和 <code>Hash()</code> 方法，这样可以通过结构体的域计算出唯一的数字或者字符串的 <code>key</code>。</p>
</li>
<li><p><code>value</code> 可以是任意类型的；通过使用空接口类型，我们可以存储任意值，但是使用这种类型作为值时需要先做一次类型断言</p>
</li>
<li>从数组和切片的索引中直接读取要比 从 <code>map</code>中读取 快100倍左右</li>
</ul>
<h3 id="map-操作"><a href="#map-操作" class="headerlink" title="map 操作"></a>map 操作</h3><h4 id="判断是否存在"><a href="#判断是否存在" class="headerlink" title="判断是否存在"></a>判断是否存在</h4><p>如果你只是想判断某个 key 是否存在而不关心它对应的值到底是多少，你可以这么做：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">_, ok := map1[key1] <span class="comment">// 如果key1存在则ok == true，否则ok为false</span></span><br></pre></td></tr></table></figure>
<h4 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h4><p>从 <code>map1</code>中删除 <code>key1</code>：<br>直接 <code>delete(map1, key1)</code> 就可以。<br>如果 <code>key1</code> 不存在，该操作不会产生错误。</p>
<h3 id="使用-函数func-int-作为值的-map："><a href="#使用-函数func-int-作为值的-map：" class="headerlink" title="使用 函数func() int 作为值的 map："></a>使用 函数<code>func() int</code> 作为值的 <code>map</code>：</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    mf := <span class="keyword">map</span>[<span class="keyword">int</span>]<span class="function"><span class="keyword">func</span><span class="params">()</span> <span class="title">int</span></span>&#123;</span><br><span class="line">        <span class="number">1</span>: <span class="function"><span class="keyword">func</span><span class="params">()</span> <span class="title">int</span></span> &#123; <span class="keyword">return</span> <span class="number">10</span> &#125;,</span><br><span class="line">        <span class="number">2</span>: <span class="function"><span class="keyword">func</span><span class="params">()</span> <span class="title">int</span></span> &#123; <span class="keyword">return</span> <span class="number">20</span> &#125;,</span><br><span class="line">        <span class="number">5</span>: <span class="function"><span class="keyword">func</span><span class="params">()</span> <span class="title">int</span></span> &#123; <span class="keyword">return</span> <span class="number">50</span> &#125;,</span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Println(mf)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出结果为：<code>map[1:0x10903be0 5:0x10903ba0 2:0x10903bc0]</code>: 整形都被映射到函数地址。</p>
<h2 id="结构体"><a href="#结构体" class="headerlink" title="结构体"></a>结构体</h2><p>使用结构体的一个典型例子：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Interval <span class="keyword">struct</span> &#123;</span><br><span class="line">    start <span class="keyword">int</span></span><br><span class="line">    end   <span class="keyword">int</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>初始化方式：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">intr := Interval&#123;<span class="number">0</span>, <span class="number">3</span>&#125;            (A)</span><br><span class="line">intr := Interval&#123;end:<span class="number">5</span>, start:<span class="number">1</span>&#125;  (B)</span><br><span class="line">intr := Interval&#123;end:<span class="number">5</span>&#125;           (C)</span><br></pre></td></tr></table></figure>
<p>在<code>（A）</code>中，值必须以字段在结构体定义时的顺序给出，<code>&amp;</code> 不是必须的。<br><code>（B）</code>显示了另一种方式，字段名加一个冒号放在值的前面，这种情况下值的顺序不必一致，并且某些字段还可以被忽略掉，就像<code>（C）</code>中那样。</p>
<h3 id="结构体不同实例化方式-内存布局"><a href="#结构体不同实例化方式-内存布局" class="headerlink" title="结构体不同实例化方式 内存布局"></a>结构体不同实例化方式 内存布局</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Point <span class="keyword">struct</span> &#123; x, y <span class="keyword">int</span> &#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><p>使用 <code>new</code> 初始化：<br><img src="http://pgqbhubpz.bkt.clouddn.com/2018-10-17-15355410073741.jpg" alt=""></p>
</li>
<li><p>作为结构体字面量初始化：<br><img src="http://pgqbhubpz.bkt.clouddn.com/2018-10-17-15355410444312.jpg" alt=""></p>
</li>
<li><p><code>Go</code> 语言中，结构体和它所包含的数据在内存中是以连续块的形式存在的，即使结构体中嵌套有其他的结构体，这在性能上带来了很大的优势</p>
</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Rect1 <span class="keyword">struct</span> &#123;Min, Max Point &#125;</span><br><span class="line"><span class="keyword">type</span> Rect2 <span class="keyword">struct</span> &#123;Min, Max *Point &#125;</span><br></pre></td></tr></table></figure>
<p><img src="http://pgqbhubpz.bkt.clouddn.com/2018-10-17-15355422703943.jpg" alt=""></p>
<h3 id="结构体的实例化及方法的调用"><a href="#结构体的实例化及方法的调用" class="headerlink" title="结构体的实例化及方法的调用"></a>结构体的实例化及方法的调用</h3><p>下面代码有一个结构体 <code>Person</code>，一个方法，方法有一个类型为 <code>*Person</code> 的参数（因此对象本身是可以被改变的），以及三种调用这个方法的不同方式：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">    <span class="string">"strings"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Person <span class="keyword">struct</span> &#123;</span><br><span class="line">    firstName   <span class="keyword">string</span></span><br><span class="line">    lastName    <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">upPerson</span><span class="params">(p *Person)</span></span> &#123;</span><br><span class="line">    p.firstName = strings.ToUpper(p.firstName)</span><br><span class="line">    p.lastName = strings.ToUpper(p.lastName)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// 1-struct as a value type:</span></span><br><span class="line">    <span class="keyword">var</span> pers1 Person</span><br><span class="line">    pers1.firstName = <span class="string">"Chris"</span></span><br><span class="line">    pers1.lastName = <span class="string">"Woodward"</span></span><br><span class="line">    upPerson(&amp;pers1)</span><br><span class="line">    fmt.Printf(<span class="string">"The name of the person is %s %s\n"</span>, pers1.firstName, pers1.lastName)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2—struct as a pointer:</span></span><br><span class="line">    pers2 := <span class="built_in">new</span>(Person)</span><br><span class="line">    pers2.firstName = <span class="string">"Chris"</span></span><br><span class="line">    pers2.lastName = <span class="string">"Woodward"</span></span><br><span class="line">    (*pers2).lastName = <span class="string">"Woodward"</span>  <span class="comment">// 这是合法的</span></span><br><span class="line">    upPerson(pers2)</span><br><span class="line">    fmt.Printf(<span class="string">"The name of the person is %s %s\n"</span>, pers2.firstName, pers2.lastName)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3—struct as a literal:</span></span><br><span class="line">    pers3 := &amp;Person&#123;<span class="string">"Chris"</span>,<span class="string">"Woodward"</span>&#125;</span><br><span class="line">    upPerson(pers3)</span><br><span class="line">    fmt.Printf(<span class="string">"The name of the person is %s %s\n"</span>, pers3.firstName, pers3.lastName)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="map-、struct-和-new-、-make-需要注意的地方"><a href="#map-、struct-和-new-、-make-需要注意的地方" class="headerlink" title="map 、struct 和 new() 、 make()需要注意的地方"></a>map 、struct 和 new() 、 make()需要注意的地方</h3><p>下面的例子说明了在映射上使用 <code>new</code> 和 <code>make</code> 的区别以及可能发生的错误：</p>
<p><code>new_make.go</code>（不能编译）</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Foo <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">string</span></span><br><span class="line"><span class="keyword">type</span> Bar <span class="keyword">struct</span> &#123;</span><br><span class="line">    thingOne <span class="keyword">string</span></span><br><span class="line">    thingTwo <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// OK</span></span><br><span class="line">    y := <span class="built_in">new</span>(Bar)</span><br><span class="line">    (*y).thingOne = <span class="string">"hello"</span></span><br><span class="line">    (*y).thingTwo = <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// NOT OK</span></span><br><span class="line">    z := <span class="built_in">make</span>(Bar) <span class="comment">// 编译错误：cannot make type Bar</span></span><br><span class="line">    (*z).thingOne = <span class="string">"hello"</span></span><br><span class="line">    (*z).thingTwo = <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// OK</span></span><br><span class="line">    x := <span class="built_in">make</span>(Foo)</span><br><span class="line">    x[<span class="string">"x"</span>] = <span class="string">"goodbye"</span></span><br><span class="line">    x[<span class="string">"y"</span>] = <span class="string">"world"</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// NOT OK</span></span><br><span class="line">    u := <span class="built_in">new</span>(Foo)</span><br><span class="line">    (*u)[<span class="string">"x"</span>] = <span class="string">"goodbye"</span> <span class="comment">// 运行时错误!! panic: assignment to entry in nil map</span></span><br><span class="line">    (*u)[<span class="string">"y"</span>] = <span class="string">"world"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>试图 <code>make()</code> 一个结构体变量，会引发一个编译错误，这还不是太糟糕，但是 <code>new()</code> 一个映射并试图使用数据填充它，将会引发运行时错误！ 因为 <code>new(Foo)</code> 返回的是一个指向 <code>nil</code> 的指针，它尚未被分配内存。所以在使用 <code>map</code> 时要特别谨慎。</p>
<h3 id="匿名字段和内嵌结构体"><a href="#匿名字段和内嵌结构体" class="headerlink" title="匿名字段和内嵌结构体"></a>匿名字段和内嵌结构体</h3><p><strong>在一个结构体中对于每一种数据类型只能有一个匿名字段。</strong></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> innerS <span class="keyword">struct</span> &#123;</span><br><span class="line">    in1 <span class="keyword">int</span></span><br><span class="line">    in2 <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> outerS <span class="keyword">struct</span> &#123;</span><br><span class="line">    b    <span class="keyword">int</span></span><br><span class="line">    c    <span class="keyword">float32</span></span><br><span class="line">    <span class="keyword">int</span>  <span class="comment">// anonymous field</span></span><br><span class="line">    innerS <span class="comment">//anonymous field</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    outer := <span class="built_in">new</span>(outerS)</span><br><span class="line">    outer.b = <span class="number">6</span></span><br><span class="line">    outer.c = <span class="number">7.5</span></span><br><span class="line">    outer.<span class="keyword">int</span> = <span class="number">60</span></span><br><span class="line">    outer.in1 = <span class="number">5</span></span><br><span class="line">    outer.in2 = <span class="number">10</span></span><br><span class="line"></span><br><span class="line">    fmt.Printf(<span class="string">"outer.b is: %d\n"</span>, outer.b)</span><br><span class="line">    fmt.Printf(<span class="string">"outer.c is: %f\n"</span>, outer.c)</span><br><span class="line">    fmt.Printf(<span class="string">"outer.int is: %d\n"</span>, outer.<span class="keyword">int</span>)</span><br><span class="line">    fmt.Printf(<span class="string">"outer.in1 is: %d\n"</span>, outer.in1)</span><br><span class="line">    fmt.Printf(<span class="string">"outer.in2 is: %d\n"</span>, outer.in2)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用结构体字面量</span></span><br><span class="line">    outer2 := outerS&#123;<span class="number">6</span>, <span class="number">7.5</span>, <span class="number">60</span>, innerS&#123;<span class="number">5</span>, <span class="number">10</span>&#125;&#125;</span><br><span class="line">    fmt.Println(<span class="string">"outer2 is:"</span>, outer2)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">outer.b is: <span class="number">6</span></span><br><span class="line">outer.c is: <span class="number">7.500000</span></span><br><span class="line">outer.<span class="keyword">int</span> is: <span class="number">60</span></span><br><span class="line">outer.in1 is: <span class="number">5</span></span><br><span class="line">outer.in2 is: <span class="number">10</span></span><br><span class="line">outer2 is:&#123;<span class="number">6</span> <span class="number">7.5</span> <span class="number">60</span> &#123;<span class="number">5</span> <span class="number">10</span>&#125;&#125;</span><br></pre></td></tr></table></figure>
<h3 id="命名冲突"><a href="#命名冲突" class="headerlink" title="命名冲突"></a>命名冲突</h3><p>当两个字段拥有相同的名字（可能是继承来的名字）时该怎么办呢？</p>
<ul>
<li>外层名字会覆盖内层名字（但是两者的内存空间都保留），这提供了一种重载字段或方法的方式；</li>
<li>如果相同的名字在同一级别出现了两次，如果这个名字被程序使用了，将会引发一个错误（不使用没关系）。没有办法来解决这种问题引起的二义性，必须由程序员自己修正。</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> B <span class="keyword">struct</span> &#123;b <span class="keyword">float32</span>&#125;</span><br><span class="line"><span class="keyword">type</span> D <span class="keyword">struct</span> &#123;B; b <span class="keyword">float32</span>&#125;</span><br><span class="line"><span class="keyword">var</span> d D</span><br></pre></td></tr></table></figure>
<p>规则1：使用 <code>d.b</code> 是没问题的：它是 <code>float32</code>，而不是 <code>B</code> 的 <code>b</code>。如果想要内层的 <code>b</code> 可以通过 <code>d.B.b</code> 得到。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> A <span class="keyword">struct</span> &#123;a <span class="keyword">int</span>&#125;</span><br><span class="line"><span class="keyword">type</span> B <span class="keyword">struct</span> &#123;a, b <span class="keyword">int</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> C <span class="keyword">struct</span> &#123;A; B&#125;</span><br><span class="line"><span class="keyword">var</span> c C</span><br></pre></td></tr></table></figure>
<p>规则 2：使用 <code>c.a</code> 是错误的，到底是 <code>c.A.a</code> 还是 <code>c.B.a</code> 呢？会导致编译器错误：<code>ambiguous DOT reference c.a disambiguate with either c.A.a or c.B.a。</code></p>
<h3 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h3><p>定义方法的一般格式如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(recv receiver_type)</span> <span class="title">methodName</span><span class="params">(parameter_list)</span> <span class="params">(return_value_list)</span></span> &#123; ... &#125;</span><br></pre></td></tr></table></figure>
<p>在方法名之前，<code>func</code> 关键字之后的括号中指定 <code>receiver</code>。</p>
<p>如果 <code>recv</code> 是 <code>receiver</code> 的实例，<code>Method1</code> 是它的方法名，那么方法调用遵循传统的 <code>object.name</code>选择器符号：<code>recv.Method1()</code>。</p>
<p>如果 <code>recv</code> 一个指针，<code>Go</code> 会自动解引用。</p>
<p>如果方法不需要使用 <code>recv</code> 的值，可以用 <code>_</code> 替换它，比如：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(_ receiver_type)</span> <span class="title">methodName</span><span class="params">(parameter_list)</span> <span class="params">(return_value_list)</span></span> &#123; ... &#125;</span><br></pre></td></tr></table></figure>
<p><code>recv</code> 就像是面向对象语言中的<code>this</code> 或 <code>self</code>，但是 <code>Go</code> 中并没有这两个关键字。随个人喜好，你可以使用 <code>this</code> 或 <code>self</code> 作为 <code>receiver</code> 的名字。<br>这就是为什么不能在 <code>int、float</code> 或类似这些的类型上定义方法。试图在 <code>int</code> 类型上定义方法会得到一个编译错误</p>
<h4 id="结构体上的简单方法的例子："><a href="#结构体上的简单方法的例子：" class="headerlink" title="结构体上的简单方法的例子："></a>结构体上的简单方法的例子：</h4><p><code>method .go：</code></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> TwoInts <span class="keyword">struct</span> &#123;</span><br><span class="line">    a <span class="keyword">int</span></span><br><span class="line">    b <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    two1 := <span class="built_in">new</span>(TwoInts)</span><br><span class="line">    two1.a = <span class="number">12</span></span><br><span class="line">    two1.b = <span class="number">10</span></span><br><span class="line"></span><br><span class="line">    fmt.Printf(<span class="string">"The sum is: %d\n"</span>, two1.AddThem())</span><br><span class="line">    fmt.Printf(<span class="string">"Add them to the param: %d\n"</span>, two1.AddToParam(<span class="number">20</span>))</span><br><span class="line"></span><br><span class="line">    two2 := TwoInts&#123;<span class="number">3</span>, <span class="number">4</span>&#125;</span><br><span class="line">    fmt.Printf(<span class="string">"The sum is: %d\n"</span>, two2.AddThem())</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(tn *TwoInts)</span> <span class="title">AddThem</span><span class="params">()</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> tn.a + tn.b</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(tn *TwoInts)</span> <span class="title">AddToParam</span><span class="params">(param <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> tn.a + tn.b + param</span><br><span class="line">&#125;</span><br><span class="line">输出：</span><br><span class="line"></span><br><span class="line">The sum is: <span class="number">22</span></span><br><span class="line">Add them to the param: <span class="number">42</span></span><br><span class="line">The sum is: <span class="number">7</span></span><br></pre></td></tr></table></figure>
<h4 id="非结构体类型上方法的例子："><a href="#非结构体类型上方法的例子：" class="headerlink" title="非结构体类型上方法的例子："></a>非结构体类型上方法的例子：</h4><p><code>method2.go：</code></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> IntVector []<span class="keyword">int</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(v IntVector)</span> <span class="title">Sum</span><span class="params">()</span> <span class="params">(s <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> _, x := <span class="keyword">range</span> v &#123;</span><br><span class="line">        s += x</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Println(IntVector&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;.Sum()) <span class="comment">// 输出是6</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h2><p>接口定义了一组方法（方法集），但是这些方法不包含（实现）代码：它们没有被实现（它们是抽象的）。接口里也不能包含变量。<br>接口是一种契约，实现类型必须满足它，它描述了类型的行为，规定类型可以做什么。接口彻底将类型能做什么，以及如何做分离开来，使得相同接口的变量在不同的时刻表现出不同的行为，这就是多态的本质。</p>
<p>编写参数是接口变量的函数，这使得它们更具有一般性。</p>
<p>使用接口使代码更具有普适性。</p>
<p>通过如下格式定义接口：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Namer <span class="keyword">interface</span> &#123;</span><br><span class="line">    Method1(param_list) return_type</span><br><span class="line">    Method2(param_list) return_type</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><p><strong>类型不需要显式声明它实现了某个接口</strong>：接口被隐式地实现。多个类型可以实现同一个接口。</p>
</li>
<li><p>实现某个接口的类型（除了实现接口方法外）可以有其他的方法。</p>
</li>
<li><p>一个类型可以实现多个接口。</p>
</li>
<li><p>接口类型可以包含一个实例的引用， 该实例的类型实现了此接口（接口是动态类型）。</p>
</li>
<li><p>即使接口在类型之后才定义，二者处于不同的包中，被单独编译：<strong>只要类型实现了接口中的方法，它就实现了此接口。</strong></p>
</li>
</ul>
<blockquote>
<p>有的时候，也会以一种稍微不同的方式来使用接口这个词：从某个类型的角度来看，它的接口指的是：它的所有导出方法，只不过没有显式地为这些导出方法额外定一个接口而已。</p>
</blockquote>
<h3 id="在接口上调用方法时，必须有和方法定义时相同的接收者类型或者是可以从具体类型-P-直接可以辨识的"><a href="#在接口上调用方法时，必须有和方法定义时相同的接收者类型或者是可以从具体类型-P-直接可以辨识的" class="headerlink" title="在接口上调用方法时，必须有和方法定义时相同的接收者类型或者是可以从具体类型 P 直接可以辨识的"></a>在接口上调用方法时，必须有和方法定义时相同的接收者类型或者是可以从具体类型 P 直接可以辨识的</h3><ul>
<li>指针方法可以通过指针调用</li>
<li>值方法可以通过值调用</li>
<li><strong>接收者是值的方法可以通过指针调用，因为指针会首先被解引用</strong></li>
<li>接收者是指针的方法不可以通过值调用，因为存储在接口中的值没有地址</li>
</ul>
<h3 id="类型断言：如何检测和转换接口变量的类型"><a href="#类型断言：如何检测和转换接口变量的类型" class="headerlink" title="类型断言：如何检测和转换接口变量的类型"></a>类型断言：如何检测和转换接口变量的类型</h3><p>可以使用 类型断言 来测试在某个时刻 <code>varI</code> 是否包含类型 <code>T</code> 的值：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">v := varI.(T)       <span class="comment">// unchecked type assertion</span></span><br></pre></td></tr></table></figure>
<p><strong><code>varI</code> 必须是一个接口变量</strong>，否则编译器会报错：<code>invalid type assertion: varI.(T) (non-interface type (type of varI) on left)</code> 。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> v, ok := varI.(T); ok &#123;  <span class="comment">// checked type assertion</span></span><br><span class="line">    Process(v)</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// varI is not of type T</span></span><br></pre></td></tr></table></figure>
<p>如果转换合法，<code>v</code> 是 <code>varI</code> 转换到类型 <code>T</code> 的值，<code>ok</code> 会是 <code>true</code>；否则 <code>v</code> 是类型 <code>T</code> 的零值，<code>ok</code> 是 <code>false</code>，也没有运行时错误发生。<br><strong>应该总是使用上面的方式来进行类型断言。</strong></p>
<h4 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">    <span class="string">"math"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Square <span class="keyword">struct</span> &#123;</span><br><span class="line">    side <span class="keyword">float32</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Circle <span class="keyword">struct</span> &#123;</span><br><span class="line">    radius <span class="keyword">float32</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Shaper <span class="keyword">interface</span> &#123;</span><br><span class="line">    Area() <span class="keyword">float32</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> areaIntf Shaper</span><br><span class="line">    sq1 := <span class="built_in">new</span>(Square)</span><br><span class="line">    sq1.side = <span class="number">5</span></span><br><span class="line"></span><br><span class="line">    areaIntf = sq1</span><br><span class="line">    <span class="comment">// Is Square the type of areaIntf?</span></span><br><span class="line">    <span class="keyword">if</span> t, ok := areaIntf.(*Square); ok &#123;</span><br><span class="line">        fmt.Printf(<span class="string">"The type of areaIntf is: %T\n"</span>, t)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> u, ok := areaIntf.(*Circle); ok &#123;</span><br><span class="line">        fmt.Printf(<span class="string">"The type of areaIntf is: %T\n"</span>, u)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        fmt.Println(<span class="string">"areaIntf does not contain a variable of type Circle"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(sq *Square)</span> <span class="title">Area</span><span class="params">()</span> <span class="title">float32</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> sq.side * sq.side</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(ci *Circle)</span> <span class="title">Area</span><span class="params">()</span> <span class="title">float32</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> ci.radius * ci.radius * math.Pi</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>程序中定义了一个新类型 <code>Circle</code>，它也实现了 <code>Shaper</code> 接口。 <code>t, ok := areaIntf.(*Square); ok</code> 测试 <code>areaIntf</code> 里是否包含 <code>Square</code> 类型的变量，结果是确定的；然后我们测试它是否包含一个 <code>Circle</code> 类型的变量，结果是否定的。</p>
<blockquote>
<p><strong>注意</strong><br>如果忽略 <code>areaIntf.(*Square)</code> 中的 <code>*</code> 号，会导致编译错误：<code>impossible type assertion: Square does not implement Shaper (Area method has pointer receiver)</code>。</p>
</blockquote>
<h4 id="type-switch"><a href="#type-switch" class="headerlink" title="type-switch"></a>type-switch</h4><p>可以用 <code>type-switch</code> 进行运行时类型分析，但是在 <code>type-switch</code> 不允许有 <code>fallthrough</code> 。<br>如果仅仅是测试变量的类型，不用它的值，那么就可以不需要赋值语句，比如：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span> areaIntf.(<span class="keyword">type</span>) &#123;</span><br><span class="line"><span class="keyword">case</span> *Square:</span><br><span class="line">    <span class="comment">// TODO</span></span><br><span class="line"><span class="keyword">case</span> *Circle:</span><br><span class="line">    <span class="comment">// TODO</span></span><br><span class="line">...</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">    <span class="comment">// TODO</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="复制数据切片至空接口切片"><a href="#复制数据切片至空接口切片" class="headerlink" title="复制数据切片至空接口切片"></a>复制数据切片至空接口切片</h3><p>必须使用 <code>for-range</code> 语句来一个一个显式地复制：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> dataSlice []myType = FuncReturnSlice()</span><br><span class="line"><span class="keyword">var</span> interfaceSlice []<span class="keyword">interface</span>&#123;&#125; = <span class="built_in">make</span>([]<span class="keyword">interface</span>&#123;&#125;, <span class="built_in">len</span>(dataSlice))</span><br><span class="line"><span class="keyword">for</span> i, d := <span class="keyword">range</span> dataSlice &#123;</span><br><span class="line">    interfaceSlice[i] = d</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="反射"><a href="#反射" class="headerlink" title="反射"></a>反射</h3><p>变量的最基本信息就是类型和值：反射包的 <code>Type</code> 用来表示一个 <code>Go</code> 类型，反射包的 <code>Value</code> 为 <code>Go</code>值提供了反射接口。</p>
<p>两个简单的函数，<code>reflect.TypeOf</code> 和 <code>reflect.ValueOf</code>，返回被检查对象的类型和值。例如，<code>x</code> 被定义为：<code>var x float64 = 3.4</code>，那么 <code>reflect.TypeOf(x)</code> 返回 <code>float64</code>，<code>reflect.ValueOf(x)</code> 返回 <code>&lt;float64 Value&gt;</code></p>
<p>对于 <code>float64</code> 类型的变量 <code>x</code>，如果 <code>v:=reflect.ValueOf(x)</code>，那么 <code>v.Kind()</code> 返回 <code>reflect.Float64</code> ，所以下面的表达式是 <code>true</code><br><code>v.Kind() == reflect.Float64</code></p>
<p><code>Kind</code> 总是返回底层类型：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> MyInt <span class="keyword">int</span></span><br><span class="line"><span class="keyword">var</span> m MyInt = <span class="number">5</span></span><br><span class="line">v := reflect.ValueOf(m)</span><br></pre></td></tr></table></figure>
<p>方法 <code>v.Kind()</code> 返回 <code>reflect.Int</code>。</p>
<h4 id="通过反射修改-设置-值"><a href="#通过反射修改-设置-值" class="headerlink" title="通过反射修改(设置)值"></a>通过反射修改(设置)值</h4><p>当 <code>v := reflect.ValueOf(x)</code> 函数通过传递一个 <code>x</code> 拷贝创建了 <code>v</code>，那么 <code>v</code> 的改变并不能更改原始的 <code>x</code>。要想 <code>v</code> 的更改能作用到 <code>x</code>，那就必须传递 <code>x</code> 的地址 <code>v = reflect.ValueOf(&amp;x)</code>。<br>通过 <code>Type()</code> 我们看到 <code>v</code> 现在的类型是 <code>*float64</code> 并且仍然是不可设置的。<br>是否可设置是 <code>Value</code> 的一个属性，并且不是所有的反射值都有这个属性：可以使用 <code>CanSet()</code> 方法测试是否可设置。<br>要想让其可设置我们需要使用 <code>Elem()</code> 函数，这间接的使用指针：<code>v = v.Elem()</code><br>现在 <code>v.CanSet()</code> 返回 <code>true</code> 并且 <code>v.SetFloat(3.1415)</code> 设置成功了！</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">    <span class="string">"reflect"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> x <span class="keyword">float64</span> = <span class="number">3.4</span></span><br><span class="line">    v := reflect.ValueOf(x)</span><br><span class="line">    <span class="comment">// setting a value:</span></span><br><span class="line">    <span class="comment">// v.SetFloat(3.1415) // Error: will panic: reflect.Value.SetFloat using unaddressable value</span></span><br><span class="line">    fmt.Println(<span class="string">"settability of v:"</span>, v.CanSet())</span><br><span class="line">    v = reflect.ValueOf(&amp;x) <span class="comment">// Note: take the address of x.</span></span><br><span class="line">    fmt.Println(<span class="string">"type of v:"</span>, v.Type())</span><br><span class="line">    fmt.Println(<span class="string">"settability of v:"</span>, v.CanSet())</span><br><span class="line">    v = v.Elem()</span><br><span class="line">    fmt.Println(<span class="string">"The Elem of v is: "</span>, v)</span><br><span class="line">    fmt.Println(<span class="string">"settability of v:"</span>, v.CanSet())</span><br><span class="line">    v.SetFloat(<span class="number">3.1415</span>) <span class="comment">// this works!</span></span><br><span class="line">    fmt.Println(v.Interface())</span><br><span class="line">    fmt.Println(v)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出</span></span><br><span class="line">settability of v: <span class="literal">false</span></span><br><span class="line"><span class="keyword">type</span> of v: *<span class="keyword">float64</span></span><br><span class="line">settability of v: <span class="literal">false</span></span><br><span class="line">The Elem of v is:  &lt;<span class="keyword">float64</span> Value&gt;</span><br><span class="line">settability of v: <span class="literal">true</span></span><br><span class="line"><span class="number">3.1415</span></span><br><span class="line">&lt;<span class="keyword">float64</span> Value&gt;</span><br></pre></td></tr></table></figure>
<h3 id="GO中的面向对象"><a href="#GO中的面向对象" class="headerlink" title="GO中的面向对象"></a>GO中的面向对象</h3><p><code>Go</code> 没有类，而是松耦合的类型、方法对接口的实现。</p>
<p><code>OO</code> 语言最重要的三个方面分别是：<code>封装，继承和多态</code>，在 <code>Go</code> 中它们是怎样表现的呢？<br>类型只拥有自己所在包中定义的方法。</p>
<ul>
<li><p>封装（数据隐藏）：和别的 <code>OO</code> 语言有 <code>4</code> 个或更多的访问层次相比，<code>Go</code> 把它简化为了 <code>2</code> 层:</p>
<ul>
<li><p>1）包范围内的：通过标识符首字母小写，对象 只在它所在的包内可见</p>
</li>
<li><p>2）可导出的：通过标识符首字母大写，对象 对所在包以外也可见</p>
</li>
</ul>
</li>
<li><p>继承：用组合实现：内嵌一个（或多个）包含想要的行为（字段和方法）的类型；多重继承可以通过内嵌多个类型实现</p>
</li>
<li>多态：用接口实现：某个类型的实例可以赋给它所实现的任意接口类型的变量。类型和接口是松耦合的，并且多重继承可以通过实现多个接口实现。<code>Go</code> 接口不是 <code>Java</code> 和 <code>C#</code> 接口的变体，而且：接口间是不相关的，并且是大规模编程和可适应的演进型设计的关键。</li>
</ul>
<h2 id="读写数据"><a href="#读写数据" class="headerlink" title="读写数据"></a>读写数据</h2><h3 id="文件读"><a href="#文件读" class="headerlink" title="文件读"></a>文件读</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">"bufio"</span></span><br><span class="line">	<span class="string">"fmt"</span></span><br><span class="line">	<span class="string">"io"</span></span><br><span class="line">	<span class="string">"os"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> inputReader *bufio.Reader</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	inputFile, inputError := os.Open(<span class="string">"/Users/fanlingang/go/oneGo/src/github.com/imfan/hello/returnFunction.go"</span>)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> inputError != <span class="literal">nil</span> &#123;</span><br><span class="line">		fmt.Println(<span class="string">"打开文件失败，"</span>, inputError)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">defer</span> inputFile.Close()</span><br><span class="line"></span><br><span class="line">	inputReader = bufio.NewReader(inputFile)</span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		<span class="comment">//inputString, readerError := inputReader.ReadString('\n')</span></span><br><span class="line">		inputString, _, readerError := inputReader.ReadLine()</span><br><span class="line">		<span class="keyword">if</span> readerError != <span class="literal">nil</span> &#123;</span><br><span class="line">			fmt.Println(<span class="string">"读取失败,"</span>, readerError)</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//fmt.Println(inputString)</span></span><br><span class="line">		fmt.Printf(<span class="string">"%s\n"</span>, inputString)</span><br><span class="line">		<span class="keyword">if</span> readerError == io.EOF &#123;</span><br><span class="line">			<span class="keyword">return</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="文件写"><a href="#文件写" class="headerlink" title="文件写"></a>文件写</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"os"</span></span><br><span class="line">    <span class="string">"bufio"</span></span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span> <span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// var outputWriter *bufio.Writer</span></span><br><span class="line">    <span class="comment">// var outputFile *os.File</span></span><br><span class="line">    <span class="comment">// var outputError os.Error</span></span><br><span class="line">    <span class="comment">// var outputString string</span></span><br><span class="line">    outputFile, outputError := os.OpenFile(<span class="string">"output.dat"</span>, os.O_WRONLY|os.O_CREATE, <span class="number">0666</span>)</span><br><span class="line">    <span class="keyword">if</span> outputError != <span class="literal">nil</span> &#123;</span><br><span class="line">        fmt.Printf(<span class="string">"An error occurred with file opening or creation\n"</span>)</span><br><span class="line">        <span class="keyword">return</span>  </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">defer</span> outputFile.Close()</span><br><span class="line"></span><br><span class="line">    outputWriter := bufio.NewWriter(outputFile)</span><br><span class="line">    outputString := <span class="string">"hello world!\n"</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i:=<span class="number">0</span>; i&lt;<span class="number">10</span>; i++ &#123;</span><br><span class="line">        outputWriter.WriteString(outputString)</span><br><span class="line">    &#125;</span><br><span class="line">    outputWriter.Flush()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>OpenFile</code> 函数有三个参数：文件名、一个或多个标志（使用逻辑运算符<code>“|”</code>连接），使用的文件权限。</p>
<p>我们通常会用到以下标志：</p>
<ul>
<li><code>os.O_RDONLY</code>：只读</li>
<li><code>os.O_WRONLY</code>：只写</li>
<li><code>os.O_CREATE</code>：创建：如果指定文件不存在，就创建该文件。</li>
<li><code>os.O_TRUNC</code>：截断：如果指定文件已存在，就将该文件的长度截为0。<br>在读文件的时候，文件的权限是被忽略的，所以在使用 <code>OpenFile</code> 时传入的第三个参数可以用<code>0</code>。而在写文件时，不管是 <code>Unix</code> 还是 <code>Windows</code>，都需要使用 <code>0666</code>。</li>
</ul>
</div><div class="tags"></div><div class="post-nav"><a class="next" href="/2017/05/10/es6 中变量解构赋值的用途/"></a></div></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">Copyright © 2018 <a href="/." rel="nofollow">Imfan.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div></div></div><a class="show" id="rocket" href="#top"></a><script type="text/javascript" src="/js/totop.js?v=0.0.0" async></script><script type="text/javascript" src="/js/jquery.fancybox.min.js" async></script><script type="text/javascript" src="/js/fancybox.js?v=0.0.0" async></script><link rel="stylesheet" type="text/css" href="/css/jquery.fancybox.min.css"><script type="text/javascript" src="/js/codeblock-resizer.js?v=0.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=0.0.0"></script></div></body></html>